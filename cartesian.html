<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.5.2.dev91+g39781dd" />
<title>stripy.cartesian API documentation</title>
<meta name="description" content="Copyright 2017-2019 Louis Moresi, Ben Mather â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>stripy.cartesian</code></h1>
</header>
<section id="section-intro">
<p>Copyright 2017-2019 Louis Moresi, Ben Mather</p>
<p>This file is part of Stripy.</p>
<p>Stripy is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or any later version.</p>
<p>Stripy is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the
GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License
along with Stripy.
If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">&#34;&#34;&#34;
Copyright 2017-2019 Louis Moresi, Ben Mather

This file is part of Stripy.

Stripy is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or any later version.

Stripy is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Stripy.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
&#34;&#34;&#34;

#!/usr/bin/python
# -*- coding: utf-8 -*-
from . import _tripack
from . import _srfpack
import numpy as np

try: range = xrange
except: pass

_ier_codes = {0:  &#34;no errors were encountered.&#34;,
              -1: &#34;N &lt; 3 on input.&#34;,
              -2: &#34;the first three nodes are collinear.\nSet permute to True or reorder nodes manually.&#34;,
              -3: &#34;duplicate nodes were encountered.&#34;,
              -4: &#34;an error flag was returned by a call to SWAP in ADDNOD.\n \
                   This is an internal error and should be reported to the programmer.&#34;,
              &#39;L&#39;:&#34;nodes L and M coincide for some M &gt; L.\n \
                   The linked list represents a triangulation of nodes 1 to M-1 in this case.&#34;,
              1: &#34;NCC, N, NROW, or an LCC entry is outside its valid range on input.&#34;,
              2: &#34;the triangulation data structure (LIST,LPTR,LEND) is invalid.&#34;,
              &#39;K&#39;: &#39;NPTS(K) is not a valid index in the range 1 to N.&#39;,
              9999: &#34;Triangulation encountered duplicate nodes.&#34;}


class Triangulation(object):
    &#34;&#34;&#34;
    Define a Delaunay triangulation for given Cartesian mesh points (x, y)
    where x and y vectors are 1D numpy arrays of equal length.

    Algorithm:
        R. J. Renka (1996), Algorithm 751; TRIPACK: a constrained two-
        dimensional Delaunay triangulation package,
        ACM Trans. Math. Softw., 22(1), pp 1-8,
        doi:10.1145/225545.225546.

    Args:
        x : 1D array
            Cartesian x coordinates
        y : 1D array
            Cartesian y coordinates
        refinement_levels : int
            refine the number of points in the triangulation
            (see uniformly_refine_triangulation)
        permute : bool
            randomises the order of lons and lats to improve
            triangulation efficiency and eliminate colinearity
            issues (see notes)
        tree : bool
            construct a cKDtree for efficient nearest-neighbour lookup

    Attributes:
        x : array of floats, shape (n,)
            stored Cartesian x coordinates from input
        y : array of floats, shape (n,)
            stored Cartesian y coordinates from input
        simplices : array of ints, shape (nsimplex, 3)
            indices of the points forming the simplices in the triangulation
            points are ordered anticlockwise
        lst : array of ints, shape (6n-12,)
            nodal indices with lptr and lend, define the triangulation as a set of N
            adjacency lists; counterclockwise-ordered sequences of neighboring nodes
            such that the first and last neighbors of a boundary node are boundary
            nodes (the first neighbor of an interior node is arbitrary).  In order to
            distinguish between interior and boundary nodes, the last neighbor of
            each boundary node is represented by the negative of its index.
            The indices are 1-based (as in Fortran), not zero based (as in python).
        lptr : array of ints, shape (6n-12),)
            set of pointers in one-to-one correspondence with the elements of lst.
            lst(lptr(i)) indexes the node which follows lst(i) in cyclical
            counterclockwise order (the first neighbor follows the last neighbor).
            The indices are 1-based (as in Fortran), not zero based (as in python).
        lend : array of ints, shape (n,)
            N pointers to adjacency lists.
            lend(k) points to the last neighbor of node K.
            lst(lend(K)) &lt; 0 if and only if K is a boundary node.
            The indices are 1-based (as in Fortran), not zero based (as in python).

    Notes:
        Provided the nodes are randomly ordered, the algorithm
        has expected time complexity \\(O(N \\log (N)\\) for most nodal
        distributions.  Note, however, that the complexity may be
        as high as \\(O(N^2)\\) if, for example, the nodes are ordered
        on increasing x.

        If `permute=True`, x and y are randomised on input before
        they are triangulated. The distribution of triangles will
        differ between setting `permute=True` and `permute=False`,
        however, the node ordering will remain identical.
    &#34;&#34;&#34;
    def __init__(self, x, y, refinement_levels=0, permute=False, tree=False):

        self.permute = permute
        self.tree = tree

        self._update_triangulation(x, y)

        for r in range(0,refinement_levels):
            x, y = self.uniformly_refine_triangulation(faces=False, trisect=False)
            self._update_triangulation(x, y)

        return


    def _generate_permutation(self, npoints):
        i = np.arange(0, npoints)
        p = np.random.permutation(npoints)
        ip = np.empty_like(p)
        ip[p[i]] = i
        return p, ip

    def _is_collinear(self, x, y):
        &#34;&#34;&#34;
        Checks if first three points are collinear
        &#34;&#34;&#34;
        pts = np.column_stack([x[:3], y[:3], np.ones(3)])
        return np.linalg.det(pts) == 0.0


    def _update_triangulation(self, x, y):

        npoints = len(x)

        # Deal with collinear issue

        if self.permute:
            niter = 0
            ierr = -2
            while ierr == -2 and niter &lt; 5:
                p, ip = self._generate_permutation(npoints)
                x = x[p]
                y = y[p]
                lst, lptr, lend, ierr = _tripack.trmesh(x, y)
                niter += 1

            if niter &gt;= 5:
                raise ValueError(_ier_codes[-2])
        else:
            p = np.arange(0, npoints)
            ip = p
            lst, lptr, lend, ierr = _tripack.trmesh(x, y)


        self._permutation = p
        self._invpermutation = ip


        if ierr &gt; 0:
            raise ValueError(&#39;ierr={} in trmesh\n{}&#39;.format(ierr, _ier_codes[9999]))
        elif ierr != 0:
            raise ValueError(&#39;ierr={} in trmesh\n{}&#39;.format(ierr, _ier_codes[ierr]))

        self.npoints = npoints
        self._x = x
        self._y = y
        self._points = np.column_stack([x, y])
        self.lst = lst
        self.lptr = lptr
        self.lend = lend

        # Convert a triangulation to a triangle list form (human readable)
        # Uses an optimised version of trlist that returns triangles
        # without neighbours or arc indices
        nt, ltri, ierr = _tripack.trlist2(lst, lptr, lend)

        if ierr != 0:
            raise ValueError(&#39;ierr={} in trlist2\n{}&#39;.format(ierr, _ier_codes[ierr]))

        # extract triangle list and convert to zero-based ordering
        self._simplices = ltri.T[:nt] - 1
        area = self.areas()
        self._simplices = self._simplices[area &gt; 0.0]

        ## If scipy is installed, build a KDtree to find neighbour points

        if self.tree:
            self._build_cKDtree()

        return

    # Define properties on each attribute to return correct ordering
    # when called

    @property
    def x(self):
        &#34;&#34;&#34; Stored Cartesian x coordinates from triangulation &#34;&#34;&#34;
        return self._deshuffle_field(self._x)
    @property
    def y(self):
        &#34;&#34;&#34; Stored Cartesian y coordinates from triangulation &#34;&#34;&#34;
        return self._deshuffle_field(self._y)
    @property
    def points(self):
        &#34;&#34;&#34; Stored Cartesian xy coordinates from triangulation &#34;&#34;&#34;
        return self._deshuffle_field(self._points)
    @property
    def simplices(self):
        &#34;&#34;&#34; Indices of the points forming the simplices in the triangulation.
        Points are ordered anticlockwise &#34;&#34;&#34;
        return self._deshuffle_simplices(self._simplices)


    def _shuffle_field(self, *args):
        &#34;&#34;&#34;
        Permute field
        &#34;&#34;&#34;

        p = self._permutation

        fields = []
        for arg in args:
            fields.append( arg[p] )

        if len(fields) == 1:
            return fields[0]
        else:
            return fields

    def _deshuffle_field(self, *args):
        &#34;&#34;&#34;
        Return to original ordering
        &#34;&#34;&#34;

        ip = self._invpermutation

        fields = []
        for arg in args:
            fields.append( arg[ip] )

        if len(fields) == 1:
            return fields[0]
        else:
            return fields

    def _deshuffle_simplices(self, simplices):
        &#34;&#34;&#34;
        Return to original ordering
        &#34;&#34;&#34;
        p = self._permutation
        return p[simplices]


    def gradient(self, f, nit=3, tol=1e-3, guarantee_convergence=False):
        &#34;&#34;&#34;
        Return the gradient of an n-dimensional array.

        The method consists of minimizing a quadratic functional Q(G) over
        gradient vectors (in x and y directions), where Q is an approximation
        to the linearized curvature over the triangulation of a C-1 bivariate
        function \\(F(x,y)\\) which interpolates the nodal values and gradients.

        Args:
            f : array of floats, shape (n,)
                field over which to evaluate the gradient
            nit : int (default: 3)
                number of iterations to reach a convergence tolerance,
                tol nit &gt;= 1
            tol: float (default: 1e-3)
                maximum change in gradient between iterations.
                convergence is reached when this condition is met.

        Returns:
            dfdx : array of floats, shape (n,)
                derivative of f in the x direction
            dfdy : array of floats, shape (n,)
                derivative of f in the y direction

        Notes:
            For SIGMA = 0, optimal efficiency was achieved in testing with
            tol = 0, and nit = 3 or 4.

            The restriction of F to an arc of the triangulation is taken to be
            the Hermite interpolatory tension spline defined by the data values
            and tangential gradient components at the endpoints of the arc, and
            Q is the sum over the triangulation arcs, excluding interior
            constraint arcs, of the linearized curvatures of F along the arcs --
            the integrals over the arcs of \\( (d^2 F / dT^2)^2\\), where \\( d^2 F / dT^2\\)is the second
            derivative of \\(F\\) with respect to distance \\(T\\) along the arc.
        &#34;&#34;&#34;
        if f.size != self.npoints:
            raise ValueError(&#39;f should be the same size as mesh&#39;)

        gradient = np.zeros((2,self.npoints), order=&#39;F&#39;, dtype=np.float32)
        sigma = 0
        iflgs = 0

        f = self._shuffle_field(f)

        ierr = 1
        while ierr == 1:
            ierr = _srfpack.gradg(self._x, self._y, f, self.lst, self.lptr, self.lend,\
                                  iflgs, sigma, gradient, nit=nit, dgmax=tol)
            if not guarantee_convergence:
                break

        if ierr &lt; 0:
            raise ValueError(&#39;ierr={} in gradg\n{}&#39;.format(ierr, _ier_codes[ierr]))

        return self._deshuffle_field(gradient[0], gradient[1])


    def gradient_local(self, f, index):
        &#34;&#34;&#34;
        Return the gradient at a specified node.

        This routine employs a local method, in which values depend only on nearby
        data points, to compute an estimated gradient at a node.

        `gradient_local()` is more efficient than `gradient()` only if it is unnecessary
        to compute gradients at all of the nodes. Both routines have similar accuracy.
        &#34;&#34;&#34;
        if f.size != self.npoints:
            raise ValueError(&#39;f should be the same size as mesh&#39;)

        f = self._shuffle_field(f)


        gradX, gradY, l = _srfpack.gradl(index + 1, self._x, self._y, f,\
                                         self.lst, self.lptr, self.lend)

        return gradX, gradY


    def smoothing(self, f, w, sm, smtol, gstol):
        r&#34;&#34;&#34;
        Smooths a surface `f` by choosing nodal function values and gradients to
        minimize the linearized curvature of F subject to a bound on the
        deviation from the data values. This is more appropriate than interpolation
        when significant errors are present in the data.

        Args:
            f : array of floats, shape (n,)
                field to apply smoothing on
            w : array of floats, shape (n,)
                weights associated with data value in `f`
                `w[i] = 1/sigma_f**2` is a good rule of thumb.
            sm : float
                positive parameter specifying an upper bound on Q2(f).
                generally `n-sqrt(2n) &lt;= sm &lt;= n+sqrt(2n)`
            smtol : float [0,1]
                specifies relative error in satisfying the constraint
                `sm(1-smtol) &lt;= Q2 &lt;= sm(1+smtol)` between 0 and 1.
            gstol : float
                tolerance for convergence.
                `gstol = 0.05*mean(sigma_f)**2` is a good rule of thumb.

        Returns:
            f_smooth : array of floats, shape (n,)
                smoothed version of f
            derivatives : tuple of floats, shape (n,3)
                \\( \partial f \partial y , \partial f \partial y \\) first derivatives
                of `f_smooth` in the x and y directions
        &#34;&#34;&#34;
        if f.size != self.npoints or f.size != w.size:
            raise ValueError(&#39;f and w should be the same size as mesh&#39;)

        f, w = self._shuffle_field(f, w)

        sigma = 0
        iflgs = 0

        f_smooth, df, ierr = _srfpack.smsurf(self.x, self.y, f, self.lst, self.lptr, self.lend,\
                                             iflgs, sigma, w, sm, smtol, gstol)

        if ierr &lt; 0:
            raise ValueError(&#39;ierr={} in gradg\n{}&#39;.format(ierr, _ier_codes[ierr]))
        if ierr == 1:
            raise RuntimeWarning(&#34;No errors were encountered but the constraint is not active --\n\
                  F, FX, and FY are the values and partials of a linear function \
                  which minimizes Q2(F), and Q1 = 0.&#34;)

        return self._deshuffle_field(f_smooth), self._deshuffle_field(df[0], df[1])


    def interpolate(self, xi, yi, zdata, order=1):
        &#34;&#34;&#34;
        Base class to handle nearest neighbour, linear, and cubic interpolation.
        Given a triangulation of a set of nodes and values at the nodes,
        this method interpolates the value at the given xi,yi coordinates.

        Args:
            xi : float / array of floats, shape (l,)
                x Cartesian coordinate(s)
            yi : float / array of floats, shape (l,)
                y Cartesian coordinate(s)
            zdata : array of floats, shape (n,)
                value at each point in the triangulation
                must be the same size of the mesh
            order : int (default=1)
                order of the interpolatory function used:
                    0 = nearest-neighbour,
                    1 = linear,
                    3 = cubic

        Returns:
            zi : float / array of floats, shape (l,)
                interpolates value(s) at (xi, yi)
            err : int / array of ints, shape (l,)
                whether interpolation (0), extrapolation (1) or error (other)
        &#34;&#34;&#34;

        if order == 0:
            return self.interpolate_nearest(xi, yi, zdata)
        elif order == 1:
            return self.interpolate_linear(xi, yi, zdata)
        elif order == 3:
            return self.interpolate_cubic(xi, yi, zdata)
        else:
            raise ValueError(&#34;order must be 0, 1, or 3&#34;)


    def interpolate_nearest(self, xi, yi, zdata):
        &#34;&#34;&#34;
        Nearest-neighbour interpolation.
        Calls nearnd to find the index of the closest neighbours to xi,yi

        Args:
            xi : float / array of floats, shape (l,)
                x coordinates on the Cartesian plane
            yi : float / array of floats, shape (l,)
                y coordinates on the Cartesian plane

        Returns:
            zi : float / array of floats, shape (l,)
                nearest-neighbour interpolated value(s) of (xi,yi)
            err : int / array of ints, shape (l,)
                whether interpolation (0), extrapolation (1) or error (other)
        &#34;&#34;&#34;
        if zdata.size != self.npoints:
            raise ValueError(&#39;zdata should be same size as mesh&#39;)

        xi = np.atleast_1d(xi)
        yi = np.atleast_1d(yi)

        size = xi.size

        zdata = self._shuffle_field(zdata)

        zierr = np.zeros(size, dtype=np.int32)
        ist = np.ones(size, dtype=np.int32)
        ist, dist = _tripack.nearnds(xi, yi, ist, self._x, self._y,
                                     self.lst, self.lptr, self.lend)

        # check if interpolation or extrapolation
        hull_idx = self.convex_hull()
        hull_pts = self.points[hull_idx]
        hull_x = hull_pts[:,0]
        hull_y = hull_pts[:,1]

        for i in range(0, zierr.size):
            vector_det = (hull_x[1:] - hull_x[:-1])*(yi[i] - hull_y[:-1]) - \
                         (hull_y[1:] - hull_y[:-1])*(xi[i] - hull_x[:-1])

            # if vector_det &gt; 0: within convex hull
            # if vector_det = 0: on top of convex hull
            # if vector_det &lt; 0: outside convex hull
            zierr[i] = (vector_det &lt; 0).any()

        return np.squeeze(zdata[ist - 1]), zierr


    def interpolate_linear(self, xi, yi, zdata):
        &#34;&#34;&#34;
        Piecewise linear interpolation / extrapolation to arbitrary point(s).
        The method is fast, but has only \\(C^0\\) continuity.

        Args:
            xi : float / array of floats, shape (l,)
                x coordinates on the Cartesian plane
            yi : float / array of floats, shape (l,)
                y coordinates on the Cartesian plane
            zdata : array of floats, shape (n,)
                value at each point in the triangulation
                must be the same size of the mesh

        Returns:
            zi : float / array of floats, shape (l,)
                interpolated value(s) of (xi,yi)
            err : int / array of ints, shape (l,)
                whether interpolation (0), extrapolation (1) or error (other)
        &#34;&#34;&#34;

        if zdata.size != self.npoints:
            raise ValueError(&#39;zdata should be same size as mesh&#39;)

        xi = np.atleast_1d(xi)
        yi = np.atleast_1d(yi)

        size = xi.size

        zi = np.empty(size)
        zierr = np.empty(size, dtype=np.int)

        zdata = self._shuffle_field(zdata)

        # iterate
        for i in range(0, size):
            ist = np.abs(self._x - xi[i]).argmin() + 1
            zi[i], zierr[i] = _srfpack.intrc0(xi[i], yi[i], self._x, self._y, zdata,\
                                       self.lst, self.lptr, self.lend, ist)

        return np.squeeze(zi), zierr


    def interpolate_cubic(self, xi, yi, zdata, gradz=None, derivatives=False):
        &#34;&#34;&#34;
        Cubic spline interpolation / extrapolation to arbirary point(s).
        This method has \\(C^1\\) continuity.

        Args:
            xi : float / array of floats, shape (l,)
                x coordinates on the Cartesian plane
            yi : float / array of floats, shape (l,)
                y coordinates on the Cartesian plane
            zdata : array of floats, shape (n,)
                value at each point in the triangulation
                must be the same size of the mesh
            gradz : array of floats, shape (2,n) (optional)
                derivative at each point in the triangulation in the
                - x-direction (first row),
                - y-direction (second row)
                if not supplied it is evaluated using `gradient()`
            derivatives : bool (default=False)
                optionally returns \\( \\frac{df}{dx} , \\frac{df}{dy} \\)
                the first derivatives at point(s) (xi,yi)

        Returns:
            zi : float / array of floats, shape (l,)
                interpolated value(s) of (xi,yi)
            err : int / array of ints, shape (l,)
                whether interpolation (0), extrapolation (1) or error (other)
            dzx, dzy (optional) : float, array of floats, shape(l,)
                first partial derivatives \\( \\partial f \\partial x , \\partial f \\partial y \\)
                at (xi,yi)
        &#34;&#34;&#34;

        if zdata.size != self.npoints:
            raise ValueError(&#39;zdata should be same size as mesh&#39;)

        if type(gradz) == type(None):
            gradX, gradY = self.gradient(zdata)
            gradX, gradY = self._shuffle_field(gradX, gradY)
        elif np.array(gradz).shape == (2,self.npoints):
            gradX, gradY = self._shuffle_field(gradz[0], gradz[1])
        else:
            raise ValueError(&#34;gradz must be of shape {}&#34;.format((2,self.npoints)))

        iflgs = 0
        dflag = 1
        sigma = 0.0


        xi = np.atleast_1d(xi)
        yi = np.atleast_1d(yi)

        size = xi.size

        zi = np.empty(size)
        dzx = np.empty(size)
        dzy = np.empty(size)
        zierr = np.empty(size, dtype=np.int)

        gradZ = np.vstack([gradX, gradY])
        zdata = self._shuffle_field(zdata)

        for i in range(0, size):
            ist = np.abs(self._x - xi[i]).argmin() + 1
            zi[i], dzx[i], dzy[i], zierr[i] = _srfpack.intrc1(xi[i], yi[i], self._x, self._y, zdata,\
                               self.lst, self.lptr, self.lend, iflgs, sigma, gradZ, dflag, ist)

        if derivatives:
            return np.squeeze(zi), zierr, (dzx, dzy)
        else:
            return np.squeeze(zi), zierr


    def neighbour_simplices(self):
        &#34;&#34;&#34;
        Get indices of neighbour simplices for each simplex.
        The kth neighbour is opposite to the kth vertex.
        For simplices at the boundary, -1 denotes no neighbour.
        &#34;&#34;&#34;
        nt, ltri, lct, ierr = _tripack.trlist(self.lst, self.lptr, self.lend, nrow=6)
        if ierr != 0:
            raise ValueError(&#39;ierr={} in trlist\n{}&#39;.format(ierr, _ier_codes[ierr]))
        return ltri.T[:nt,3:] - 1


    def neighbour_and_arc_simplices(self):
        &#34;&#34;&#34;
        Get indices of neighbour simplices for each simplex and arc indices.
        Identical to get_neighbour_simplices() but also returns an array
        of indices that reside on boundary hull, -1 denotes no neighbour.
        &#34;&#34;&#34;
        nt, ltri, lct, ierr = _tripack.trlist(self.lst, self.lptr, self.lend, nrow=9)
        if ierr != 0:
            raise ValueError(&#39;ierr={} in trlist\n{}&#39;.format(ierr, _ier_codes[ierr]))
        ltri = ltri.T[:nt] - 1
        return ltri[:,3:6], ltri[:,6:]


    def nearest_vertex(self, xi, yi):
        &#34;&#34;&#34;
        Locate the index of the nearest vertex to points (xi,yi)
        and return the squared distance between (xi,yi) and
        each nearest neighbour.

        Args:
            xi : array of floats, shape (l,)
                Cartesian coordinates in the x direction
            yi : array of floats, shape (l,)
                Cartesian coordinates in the y direction

        Returns:
            index : array of ints
                the nearest vertex to each of the supplied points
            dist : array of floats
                squared distance to the closest vertex identified

        Notes:
            Faster searches can be obtained using a KDTree.
            Store all x and y coordinates in a (c)KDTree, then query
            a set of points to find their nearest neighbours.
        &#34;&#34;&#34;
        n = np.array(xi).size
        xi = np.array(xi).reshape(n)
        yi = np.array(yi).reshape(n)

        idx  = np.empty_like(xi, dtype=np.int)
        dist = np.empty_like(xi, dtype=np.float)

        for pt in range(0, n):
            # i is the node at which we start the search
            # the closest x coordinate is a good place
            i = np.abs(self._x - xi[pt]).argmin()

            idx[pt], dist[pt] = _tripack.nearnd(xi[pt], yi[pt], i, self._x, self._y,\
                                                self.lst, self.lptr, self.lend)
        idx -= 1 # return to C ordering

        return self._deshuffle_simplices(idx), dist


    def containing_triangle(self, xi, yi):
        &#34;&#34;&#34;
        Returns indices of the triangles containing xi yi

        Args:
            xi : float / array of floats, shape (l,)
                Cartesian coordinates in the x direction
            yi : float / array of floats, shape (l,)
                Cartesian coordinates in the y direction

        Returns:
            tri_indices: array of ints, shape (l,)

        Notes:
            The simplices are found as `cartesian.Triangulation.simplices[tri_indices]`
        &#34;&#34;&#34;
        p = self._permutation
        pts = np.column_stack([xi, yi])

        sorted_simplices = np.sort(self._simplices, axis=1)

        triangles = []
        for pt in pts:
            t = _tripack.trfind(3, pt[0], pt[1], self._x, self._y, self.lst, self.lptr, self.lend)
            tri = np.sort(t) - 1

            triangles.extend(np.where(np.all(p[sorted_simplices]==p[tri], axis=1))[0])

        return np.array(triangles).ravel()


    def containing_simplex_and_bcc(self, xi, yi):
        &#34;&#34;&#34;
        Returns the simplices containing (xi,yi)
        and the local barycentric, normalised coordinates.

        Args:
            xi : float / array of floats, shape (l,)
               Cartesian coordinates in the x direction
            yi : float / array of floats, shape (l,)
               Cartesian coordinates in the y direction

        Returns:
            bcc : normalised barycentric coordinates
            tri : simplices containing (xi,yi)

        Notes:
            The ordering of the vertices may differ from that stored in
            `self.simplices` array but will still be a loop around the simplex.
        &#34;&#34;&#34;

        pts = np.column_stack([xi,yi])

        tri = np.empty((pts.shape[0], 3), dtype=np.int) # simplices
        bcc = np.empty_like(tri, dtype=np.float) # barycentric coords

        for i, pt in enumerate(pts):
            t = _tripack.trfind(3, pt[0], pt[1], self._x, self._y, self.lst, self.lptr, self.lend)
            tri[i] = t

            vert = self._points[tri[i] - 1]
            v0 = vert[1] - vert[0]
            v1 = vert[2] - vert[0]
            v2 = pt - vert[0]

            d00 = v0.dot(v0)
            d01 = v0.dot(v1)
            d11 = v1.dot(v1)
            d20 = v2.dot(v0)
            d21 = v2.dot(v1)
            denom = d00*d11 - d01*d01

            v = (d11 * d20 - d01 * d21) / denom
            w = (d00 * d21 - d01 * d20) / denom
            u = 1.0 - v - w

            bcc[i] = [u, v, w]

        tri -= 1 # return to C ordering

        bcc /= bcc.sum(axis=1).reshape(-1,1)

        return bcc, self._deshuffle_simplices(tri)


    def identify_vertex_neighbours(self, vertex):
        &#34;&#34;&#34;
        Find the neighbour-vertices in the triangulation for the given vertex
        Searches `self.simplices` for vertex entries and sorts neighbours
        &#34;&#34;&#34;
        simplices = self.simplices
        ridx, cidx = np.where(simplices == vertex)
        neighbour_array = np.unique(np.hstack([simplices[ridx]])).tolist()
        neighbour_array.remove(vertex)
        return neighbour_array



    def identify_vertex_triangles(self, vertices):
        &#34;&#34;&#34;
        Find all triangles which own any of the vertices in the list provided
        &#34;&#34;&#34;

        triangles = []

        for vertex in np.array(vertices).reshape(-1):
            triangles.append(np.where(self.simplices == vertex)[0])

        return np.unique(np.concatenate(triangles))


    def identify_segments(self):
        &#34;&#34;&#34;
        Find all the segments in the triangulation and return an
        array of vertices (n1,n2) where n1 &lt; n2
        &#34;&#34;&#34;

        i1 = np.sort([self._simplices[:,0], self._simplices[:,1]], axis=0)
        i2 = np.sort([self._simplices[:,0], self._simplices[:,2]], axis=0)
        i3 = np.sort([self._simplices[:,1], self._simplices[:,2]], axis=0)

        a = np.hstack([i1, i2, i3]).T

        # find unique rows in numpy array
        # &lt;http://stackoverflow.com/questions/16970982/find-unique-rows-in-numpy-array&gt;
        b = np.ascontiguousarray(a).view(np.dtype((np.void, a.dtype.itemsize * a.shape[1])))
        segments = np.unique(b).view(a.dtype).reshape(-1, a.shape[1])

        return self._deshuffle_simplices(segments)


    def segment_midpoints_by_vertices(self, vertices):
        &#34;&#34;&#34;
        Add midpoints to any segment connected to the vertices in the
        list / array provided.
        &#34;&#34;&#34;

        segments = set()

        for vertex in vertices:
            neighbours = self.identify_vertex_neighbours(vertex)
            segments.update( min( tuple((vertex, n1)), tuple((n1, vertex))) for n1 in neighbours )

        segs = np.array(list(segments))

        new_midpoints = self.segment_midpoints(segments=segs)

        return new_midpoints


    def face_midpoints(self, simplices=None):
        &#34;&#34;&#34;
        Identify the centroid of every simplex in the triangulation. If an array of
        simplices is given then the centroids of only those simplices is returned.
        &#34;&#34;&#34;

        if type(simplices) == type(None):
            simplices = self.simplices

        mids = self.points[simplices].mean(axis=1)
        mid_xpt, mid_ypt = mids[:,0], mids[:,1]

        return mid_xpt, mid_ypt


    def segment_midpoints(self, segments=None):
        &#34;&#34;&#34;
        Identify the midpoints of every line segment in the triangulation.
        If an array of segments of shape (no_of_segments,2) is given,
        then the midpoints of only those segments is returned.

        Notes:
            Segments in the array must not be duplicates or the re-triangulation
            will fail. Take care not to miss that (n1,n2) is equivalent to (n2,n1).
        &#34;&#34;&#34;

        if type(segments) == type(None):
            segments = self.identify_segments()
        points = self.points

        mids = (points[segments[:,0]] + points[segments[:,1]]) * 0.5
        mid_xpt, mid_ypt = mids[:,0], mids[:,1]

        return mid_xpt, mid_ypt


    def segment_tripoints(self, ratio=0.33333):
        &#34;&#34;&#34;
        Identify the trisection points of every line segment in the triangulation
        &#34;&#34;&#34;

        segments = self.identify_segments()
        points = self.points

        mids1 = ratio*points[segments[:,0]] + (1.0-ratio)*points[segments[:,1]]
        mids2 = (1.0-ratio)*points[segments[:,0]] + ratio*points[segments[:,1]]

        mids = np.vstack((mids1,mids2))
        mid_xpt, mid_ypt = mids[:,0], mids[:,1]

        return mid_xpt, mid_ypt


    def convex_hull(self):
        &#34;&#34;&#34;
        Find the Convex Hull of the internal set of x,y points.

        Returns:
            bnodes : array of ints
                indices corresponding to points on the convex hull
        &#34;&#34;&#34;
        bnodes, nb, na, nt = _tripack.bnodes(self.lst, self.lptr, self.lend, self.npoints)
        return self._deshuffle_simplices(bnodes[:nb] - 1)


    def areas(self):
        &#34;&#34;&#34;
        Compute the area of each triangle within the triangulation of points.

        Returns:
            area : array of floats, shape (nt,)
                area of each triangle in `self.simplices` where nt
                is the number of triangles.

        &#34;&#34;&#34;
        v1 = self.points[self.simplices[:,1]] - self.points[self.simplices[:,0]]
        v2 = self.points[self.simplices[:,2]] - self.points[self.simplices[:,1]]

        area = 0.5*(v1[:,0]*v2[:,1] - v1[:,1]*v2[:,0])
        return area


    def edge_lengths(self):
        &#34;&#34;&#34;
        Compute the edge-lengths of each triangle in the triangulation.
        &#34;&#34;&#34;
        simplex = self.simplices.T

        # simplex is vectors a, b, c defining the corners
        a = self.points[simplex[0]]
        b = self.points[simplex[1]]
        c = self.points[simplex[2]]

        # norm to calculate length
        ab = np.linalg.norm(b - a, axis=1)
        bc = np.linalg.norm(c - a, axis=1)
        ac = np.linalg.norm(a - c, axis=1)

        return ab, bc, ac


    def _add_midpoints(self):

        mid_xpt, mid_ypt = self.segment_midpoints()

        x_v2 = np.concatenate([self.x, mid_xpt], axis=0)
        y_v2 = np.concatenate([self.y, mid_ypt], axis=0)

        return x_v2, y_v2

    def _add_tripoints(self, ratio=0.333333):

        mid_xpt, mid_ypt = self.segment_tripoints()

        x_v2 = np.concatenate([self.x, mid_xpt], axis=0)
        y_v2 = np.concatenate([self.y, mid_ypt], axis=0)

        return x_v2, y_v2

    def _add_face_centroids(self):

        face_xpt, face_ypt = self.face_midpoints()

        x_v2 = np.concatenate((self.x, face_xpt), axis=0)
        y_v2 = np.concatenate((self.y, face_ypt), axis=0)

        return x_v2, y_v2


    def uniformly_refine_triangulation(self, faces=False, trisect=False):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation
        &#34;&#34;&#34;

        if faces:
            x_v1, y_v1 = self._add_face_centroids()

        else:
            if not trisect:
                x_v1, y_v1 = self._add_midpoints()
            else:
                x_v1, y_v1 = self._add_tripoints(ratio=0.333333)

        return x_v1, y_v1


    def midpoint_refine_triangulation_by_vertices(self, vertices):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation connected to any of the vertices in the list provided
        &#34;&#34;&#34;

        xi, yi = self.segment_midpoints_by_vertices(vertices=vertices)

        x_v1 = np.concatenate((self.x, xi), axis=0)
        y_v1 = np.concatenate((self.y, yi), axis=0)

        return x_v1, y_v1


    def edge_refine_triangulation_by_triangles(self, triangles):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation that are associated with the triangles in the list
        of indices provided.

        Notes:
            The triangles are here represented as a single index.
            The vertices of triangle `i` are given by `self.simplices[i]`.
        &#34;&#34;&#34;

        ## Note there should be no duplicates in the list of triangles
        ## but because we remove duplicates from the list of all segments,
        ## there is no pressing need to check this.

        # identify the segments

        simplices = self.simplices
        segments = set()

        for index in np.array(triangles).reshape(-1):
            tri = simplices[index]
            segments.add( min( tuple((tri[0], tri[1])), tuple((tri[0], tri[1]))) )
            segments.add( min( tuple((tri[1], tri[2])), tuple((tri[2], tri[1]))) )
            segments.add( min( tuple((tri[0], tri[2])), tuple((tri[2], tri[0]))) )

        segs = np.array(list(segments))

        xi, yi = self.segment_midpoints(segs)

        x_v1 = np.concatenate((self.x, xi), axis=0)
        y_v1 = np.concatenate((self.y, yi), axis=0)

        return x_v1, y_v1


    def edge_refine_triangulation_by_vertices(self, vertices):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation connected to any of the vertices in the list provided
        &#34;&#34;&#34;

        triangles = self.identify_vertex_triangles(vertices)

        return self.edge_refine_triangulation_by_triangles(triangles)


    def centroid_refine_triangulation_by_triangles(self, triangles):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation that are associated with the triangles in the list provided.

        Notes:
            The triangles are here represented as a single index.
            The vertices of triangle `i` are given by `self.simplices[i]`.
        &#34;&#34;&#34;

        # Remove duplicates from the list of triangles

        triangles = np.unique(np.array(triangles))

        xi, yi = self.face_midpoints(simplices=self.simplices[triangles])

        x_v1 = np.concatenate((self.x, xi), axis=0)
        y_v1 = np.concatenate((self.y, yi), axis=0)

        return x_v1, y_v1


    def centroid_refine_triangulation_by_vertices(self, vertices):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation connected to any of the vertices in the list provided
        &#34;&#34;&#34;

        triangles = self.identify_vertex_triangles(vertices)

        return self.centroid_refine_triangulation_by_triangles(triangles)


    def join(self, t2, unique=False):
        &#34;&#34;&#34;
        Join this triangulation with another. If the points are known to have no duplicates, then
        set unique=False to skip the testing and duplicate removal
        &#34;&#34;&#34;

        x_v1 = np.concatenate((self.x, t2.x), axis=0)
        y_v1 = np.concatenate((self.y, t2.y), axis=0)

        ## remove any duplicates

        if not unique:
            a = np.ascontiguousarray(np.vstack((x_v1, y_v1)).T)
            unique_a = np.unique(a.view([(&#39;&#39;, a.dtype)]*a.shape[1]))
            unique_coords = unique_a.view(a.dtype).reshape((unique_a.shape[0], a.shape[1]))

            x_v1 = unique_coords[:,0]
            y_v1 = unique_coords[:,1]

        return x_v1, y_v1


    def _build_cKDtree(self):

        try:
            import scipy.spatial
            self._cKDtree = scipy.spatial.cKDTree(self.points)

        except:
            self._cKDtree = None


    def nearest_vertices(self, x, y, k=1, max_distance=np.inf ):
        &#34;&#34;&#34;
        Query the cKDtree for the nearest neighbours and Euclidean
        distance from x,y points.

        Returns 0, 0 if a cKDtree has not been constructed
        (switch `tree=True` if you need this routine)

        Args:
            x : 1D array of Cartesian x coordinates
            y : 1D array of Cartesian y coordinates
            k : int (defaul=1)
                number of nearest neighbours to return
            max_distance : float (default: inf)
                maximum Euclidean distance to search for neighbours

        Returns:
            d : array of floats
                Euclidean distance between each point and their
                nearest neighbour(s)
            vert : array of ints
                vertices of the nearest neighbour(s)
        &#34;&#34;&#34;

        if self.tree == False or self.tree == None:
            return 0, 0

        xy = np.column_stack([x, y])

        dxy, vertices = self._cKDtree.query(xy, k=k, distance_upper_bound=max_distance)


        if k == 1:   # force this to be a 2D array
            vertices = np.reshape(vertices, (-1, 1))

        return dxy, vertices


def remove_duplicates(vector_tuple):
    &#34;&#34;&#34;
    Remove duplicates rows from N equally-sized arrays
    &#34;&#34;&#34;
    array = np.column_stack(vector_tuple)
    a = np.ascontiguousarray(array)
    unique_a = np.unique(a.view([(&#39;&#39;, a.dtype)]*a.shape[1]))
    b = unique_a.view(a.dtype).reshape((unique_a.shape[0], a.shape[1]))
    return list(b.T)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="stripy.cartesian.remove_duplicates"><code class="name flex">
<span>def <span class="ident">remove_duplicates</span></span>(<span>vector_tuple)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove duplicates rows from N equally-sized arrays</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def remove_duplicates(vector_tuple):
    &#34;&#34;&#34;
    Remove duplicates rows from N equally-sized arrays
    &#34;&#34;&#34;
    array = np.column_stack(vector_tuple)
    a = np.ascontiguousarray(array)
    unique_a = np.unique(a.view([(&#39;&#39;, a.dtype)]*a.shape[1]))
    b = unique_a.view(a.dtype).reshape((unique_a.shape[0], a.shape[1]))
    return list(b.T)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="stripy.cartesian.Triangulation"><code class="flex name class">
<span>class <span class="ident">Triangulation</span></span>
<span>(</span><span>x, y, refinement_levels=0, permute=False, tree=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Define a Delaunay triangulation for given Cartesian mesh points (x, y)
where x and y vectors are 1D numpy arrays of equal length.</p>
<h2 id="algorithm">Algorithm</h2>
<p>R. J. Renka (1996), Algorithm 751; TRIPACK: a constrained two-
dimensional Delaunay triangulation package,
ACM Trans. Math. Softw., 22(1), pp 1-8,
doi:10.1145/225545.225546.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>1D</code> <code>array</code></dt>
<dd>Cartesian x coordinates</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>1D</code> <code>array</code></dt>
<dd>Cartesian y coordinates</dd>
<dt><strong><code>refinement_levels</code></strong> :&ensp;<code>int</code></dt>
<dd>refine the number of points in the triangulation
(see uniformly_refine_triangulation)</dd>
<dt><strong><code>permute</code></strong> :&ensp;<code>bool</code></dt>
<dd>randomises the order of lons and lats to improve
triangulation efficiency and eliminate colinearity
issues (see notes)</dd>
<dt><strong><code>tree</code></strong> :&ensp;<code>bool</code></dt>
<dd>construct a cKDtree for efficient nearest-neighbour lookup</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>stored Cartesian x coordinates from input</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>stored Cartesian y coordinates from input</dd>
<dt><strong><code>simplices</code></strong> :&ensp;<code>array</code> of <code>ints</code>, <code>shape</code> (<code>nsimplex</code>, <code>3</code>)</dt>
<dd>indices of the points forming the simplices in the triangulation
points are ordered anticlockwise</dd>
<dt><strong><code>lst</code></strong> :&ensp;<code>array</code> of <code>ints</code>, <code>shape</code> (<code>6n</code>-<code>12</code>,)</dt>
<dd>nodal indices with lptr and lend, define the triangulation as a set of N
adjacency lists; counterclockwise-ordered sequences of neighboring nodes
such that the first and last neighbors of a boundary node are boundary
nodes (the first neighbor of an interior node is arbitrary).
In order to
distinguish between interior and boundary nodes, the last neighbor of
each boundary node is represented by the negative of its index.
The indices are 1-based (as in Fortran), not zero based (as in python).</dd>
<dt><strong><code>lptr</code></strong> :&ensp;<code>array</code> of <code>ints</code>, <code>shape</code> (<code>6n</code>-<code>12</code>),)</dt>
<dd>set of pointers in one-to-one correspondence with the elements of lst.
lst(lptr(i)) indexes the node which follows lst(i) in cyclical
counterclockwise order (the first neighbor follows the last neighbor).
The indices are 1-based (as in Fortran), not zero based (as in python).</dd>
<dt><strong><code>lend</code></strong> :&ensp;<code>array</code> of <code>ints</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>N pointers to adjacency lists.
lend(k) points to the last neighbor of node K.
lst(lend(K)) &lt; 0 if and only if K is a boundary node.
The indices are 1-based (as in Fortran), not zero based (as in python).</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Provided the nodes are randomly ordered, the algorithm
has expected time complexity (O(N \log (N)) for most nodal
distributions.
Note, however, that the complexity may be
as high as (O(N^2)) if, for example, the nodes are ordered
on increasing x.</p>
<p>If <code>permute=True</code>, x and y are randomised on input before
they are triangulated. The distribution of triangles will
differ between setting <code>permute=True</code> and <code>permute=False</code>,
however, the node ordering will remain identical.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Triangulation(object):
    &#34;&#34;&#34;
    Define a Delaunay triangulation for given Cartesian mesh points (x, y)
    where x and y vectors are 1D numpy arrays of equal length.

    Algorithm:
        R. J. Renka (1996), Algorithm 751; TRIPACK: a constrained two-
        dimensional Delaunay triangulation package,
        ACM Trans. Math. Softw., 22(1), pp 1-8,
        doi:10.1145/225545.225546.

    Args:
        x : 1D array
            Cartesian x coordinates
        y : 1D array
            Cartesian y coordinates
        refinement_levels : int
            refine the number of points in the triangulation
            (see uniformly_refine_triangulation)
        permute : bool
            randomises the order of lons and lats to improve
            triangulation efficiency and eliminate colinearity
            issues (see notes)
        tree : bool
            construct a cKDtree for efficient nearest-neighbour lookup

    Attributes:
        x : array of floats, shape (n,)
            stored Cartesian x coordinates from input
        y : array of floats, shape (n,)
            stored Cartesian y coordinates from input
        simplices : array of ints, shape (nsimplex, 3)
            indices of the points forming the simplices in the triangulation
            points are ordered anticlockwise
        lst : array of ints, shape (6n-12,)
            nodal indices with lptr and lend, define the triangulation as a set of N
            adjacency lists; counterclockwise-ordered sequences of neighboring nodes
            such that the first and last neighbors of a boundary node are boundary
            nodes (the first neighbor of an interior node is arbitrary).  In order to
            distinguish between interior and boundary nodes, the last neighbor of
            each boundary node is represented by the negative of its index.
            The indices are 1-based (as in Fortran), not zero based (as in python).
        lptr : array of ints, shape (6n-12),)
            set of pointers in one-to-one correspondence with the elements of lst.
            lst(lptr(i)) indexes the node which follows lst(i) in cyclical
            counterclockwise order (the first neighbor follows the last neighbor).
            The indices are 1-based (as in Fortran), not zero based (as in python).
        lend : array of ints, shape (n,)
            N pointers to adjacency lists.
            lend(k) points to the last neighbor of node K.
            lst(lend(K)) &lt; 0 if and only if K is a boundary node.
            The indices are 1-based (as in Fortran), not zero based (as in python).

    Notes:
        Provided the nodes are randomly ordered, the algorithm
        has expected time complexity \\(O(N \\log (N)\\) for most nodal
        distributions.  Note, however, that the complexity may be
        as high as \\(O(N^2)\\) if, for example, the nodes are ordered
        on increasing x.

        If `permute=True`, x and y are randomised on input before
        they are triangulated. The distribution of triangles will
        differ between setting `permute=True` and `permute=False`,
        however, the node ordering will remain identical.
    &#34;&#34;&#34;
    def __init__(self, x, y, refinement_levels=0, permute=False, tree=False):

        self.permute = permute
        self.tree = tree

        self._update_triangulation(x, y)

        for r in range(0,refinement_levels):
            x, y = self.uniformly_refine_triangulation(faces=False, trisect=False)
            self._update_triangulation(x, y)

        return


    def _generate_permutation(self, npoints):
        i = np.arange(0, npoints)
        p = np.random.permutation(npoints)
        ip = np.empty_like(p)
        ip[p[i]] = i
        return p, ip

    def _is_collinear(self, x, y):
        &#34;&#34;&#34;
        Checks if first three points are collinear
        &#34;&#34;&#34;
        pts = np.column_stack([x[:3], y[:3], np.ones(3)])
        return np.linalg.det(pts) == 0.0


    def _update_triangulation(self, x, y):

        npoints = len(x)

        # Deal with collinear issue

        if self.permute:
            niter = 0
            ierr = -2
            while ierr == -2 and niter &lt; 5:
                p, ip = self._generate_permutation(npoints)
                x = x[p]
                y = y[p]
                lst, lptr, lend, ierr = _tripack.trmesh(x, y)
                niter += 1

            if niter &gt;= 5:
                raise ValueError(_ier_codes[-2])
        else:
            p = np.arange(0, npoints)
            ip = p
            lst, lptr, lend, ierr = _tripack.trmesh(x, y)


        self._permutation = p
        self._invpermutation = ip


        if ierr &gt; 0:
            raise ValueError(&#39;ierr={} in trmesh\n{}&#39;.format(ierr, _ier_codes[9999]))
        elif ierr != 0:
            raise ValueError(&#39;ierr={} in trmesh\n{}&#39;.format(ierr, _ier_codes[ierr]))

        self.npoints = npoints
        self._x = x
        self._y = y
        self._points = np.column_stack([x, y])
        self.lst = lst
        self.lptr = lptr
        self.lend = lend

        # Convert a triangulation to a triangle list form (human readable)
        # Uses an optimised version of trlist that returns triangles
        # without neighbours or arc indices
        nt, ltri, ierr = _tripack.trlist2(lst, lptr, lend)

        if ierr != 0:
            raise ValueError(&#39;ierr={} in trlist2\n{}&#39;.format(ierr, _ier_codes[ierr]))

        # extract triangle list and convert to zero-based ordering
        self._simplices = ltri.T[:nt] - 1
        area = self.areas()
        self._simplices = self._simplices[area &gt; 0.0]

        ## If scipy is installed, build a KDtree to find neighbour points

        if self.tree:
            self._build_cKDtree()

        return

    # Define properties on each attribute to return correct ordering
    # when called

    @property
    def x(self):
        &#34;&#34;&#34; Stored Cartesian x coordinates from triangulation &#34;&#34;&#34;
        return self._deshuffle_field(self._x)
    @property
    def y(self):
        &#34;&#34;&#34; Stored Cartesian y coordinates from triangulation &#34;&#34;&#34;
        return self._deshuffle_field(self._y)
    @property
    def points(self):
        &#34;&#34;&#34; Stored Cartesian xy coordinates from triangulation &#34;&#34;&#34;
        return self._deshuffle_field(self._points)
    @property
    def simplices(self):
        &#34;&#34;&#34; Indices of the points forming the simplices in the triangulation.
        Points are ordered anticlockwise &#34;&#34;&#34;
        return self._deshuffle_simplices(self._simplices)


    def _shuffle_field(self, *args):
        &#34;&#34;&#34;
        Permute field
        &#34;&#34;&#34;

        p = self._permutation

        fields = []
        for arg in args:
            fields.append( arg[p] )

        if len(fields) == 1:
            return fields[0]
        else:
            return fields

    def _deshuffle_field(self, *args):
        &#34;&#34;&#34;
        Return to original ordering
        &#34;&#34;&#34;

        ip = self._invpermutation

        fields = []
        for arg in args:
            fields.append( arg[ip] )

        if len(fields) == 1:
            return fields[0]
        else:
            return fields

    def _deshuffle_simplices(self, simplices):
        &#34;&#34;&#34;
        Return to original ordering
        &#34;&#34;&#34;
        p = self._permutation
        return p[simplices]


    def gradient(self, f, nit=3, tol=1e-3, guarantee_convergence=False):
        &#34;&#34;&#34;
        Return the gradient of an n-dimensional array.

        The method consists of minimizing a quadratic functional Q(G) over
        gradient vectors (in x and y directions), where Q is an approximation
        to the linearized curvature over the triangulation of a C-1 bivariate
        function \\(F(x,y)\\) which interpolates the nodal values and gradients.

        Args:
            f : array of floats, shape (n,)
                field over which to evaluate the gradient
            nit : int (default: 3)
                number of iterations to reach a convergence tolerance,
                tol nit &gt;= 1
            tol: float (default: 1e-3)
                maximum change in gradient between iterations.
                convergence is reached when this condition is met.

        Returns:
            dfdx : array of floats, shape (n,)
                derivative of f in the x direction
            dfdy : array of floats, shape (n,)
                derivative of f in the y direction

        Notes:
            For SIGMA = 0, optimal efficiency was achieved in testing with
            tol = 0, and nit = 3 or 4.

            The restriction of F to an arc of the triangulation is taken to be
            the Hermite interpolatory tension spline defined by the data values
            and tangential gradient components at the endpoints of the arc, and
            Q is the sum over the triangulation arcs, excluding interior
            constraint arcs, of the linearized curvatures of F along the arcs --
            the integrals over the arcs of \\( (d^2 F / dT^2)^2\\), where \\( d^2 F / dT^2\\)is the second
            derivative of \\(F\\) with respect to distance \\(T\\) along the arc.
        &#34;&#34;&#34;
        if f.size != self.npoints:
            raise ValueError(&#39;f should be the same size as mesh&#39;)

        gradient = np.zeros((2,self.npoints), order=&#39;F&#39;, dtype=np.float32)
        sigma = 0
        iflgs = 0

        f = self._shuffle_field(f)

        ierr = 1
        while ierr == 1:
            ierr = _srfpack.gradg(self._x, self._y, f, self.lst, self.lptr, self.lend,\
                                  iflgs, sigma, gradient, nit=nit, dgmax=tol)
            if not guarantee_convergence:
                break

        if ierr &lt; 0:
            raise ValueError(&#39;ierr={} in gradg\n{}&#39;.format(ierr, _ier_codes[ierr]))

        return self._deshuffle_field(gradient[0], gradient[1])


    def gradient_local(self, f, index):
        &#34;&#34;&#34;
        Return the gradient at a specified node.

        This routine employs a local method, in which values depend only on nearby
        data points, to compute an estimated gradient at a node.

        `gradient_local()` is more efficient than `gradient()` only if it is unnecessary
        to compute gradients at all of the nodes. Both routines have similar accuracy.
        &#34;&#34;&#34;
        if f.size != self.npoints:
            raise ValueError(&#39;f should be the same size as mesh&#39;)

        f = self._shuffle_field(f)


        gradX, gradY, l = _srfpack.gradl(index + 1, self._x, self._y, f,\
                                         self.lst, self.lptr, self.lend)

        return gradX, gradY


    def smoothing(self, f, w, sm, smtol, gstol):
        r&#34;&#34;&#34;
        Smooths a surface `f` by choosing nodal function values and gradients to
        minimize the linearized curvature of F subject to a bound on the
        deviation from the data values. This is more appropriate than interpolation
        when significant errors are present in the data.

        Args:
            f : array of floats, shape (n,)
                field to apply smoothing on
            w : array of floats, shape (n,)
                weights associated with data value in `f`
                `w[i] = 1/sigma_f**2` is a good rule of thumb.
            sm : float
                positive parameter specifying an upper bound on Q2(f).
                generally `n-sqrt(2n) &lt;= sm &lt;= n+sqrt(2n)`
            smtol : float [0,1]
                specifies relative error in satisfying the constraint
                `sm(1-smtol) &lt;= Q2 &lt;= sm(1+smtol)` between 0 and 1.
            gstol : float
                tolerance for convergence.
                `gstol = 0.05*mean(sigma_f)**2` is a good rule of thumb.

        Returns:
            f_smooth : array of floats, shape (n,)
                smoothed version of f
            derivatives : tuple of floats, shape (n,3)
                \\( \partial f \partial y , \partial f \partial y \\) first derivatives
                of `f_smooth` in the x and y directions
        &#34;&#34;&#34;
        if f.size != self.npoints or f.size != w.size:
            raise ValueError(&#39;f and w should be the same size as mesh&#39;)

        f, w = self._shuffle_field(f, w)

        sigma = 0
        iflgs = 0

        f_smooth, df, ierr = _srfpack.smsurf(self.x, self.y, f, self.lst, self.lptr, self.lend,\
                                             iflgs, sigma, w, sm, smtol, gstol)

        if ierr &lt; 0:
            raise ValueError(&#39;ierr={} in gradg\n{}&#39;.format(ierr, _ier_codes[ierr]))
        if ierr == 1:
            raise RuntimeWarning(&#34;No errors were encountered but the constraint is not active --\n\
                  F, FX, and FY are the values and partials of a linear function \
                  which minimizes Q2(F), and Q1 = 0.&#34;)

        return self._deshuffle_field(f_smooth), self._deshuffle_field(df[0], df[1])


    def interpolate(self, xi, yi, zdata, order=1):
        &#34;&#34;&#34;
        Base class to handle nearest neighbour, linear, and cubic interpolation.
        Given a triangulation of a set of nodes and values at the nodes,
        this method interpolates the value at the given xi,yi coordinates.

        Args:
            xi : float / array of floats, shape (l,)
                x Cartesian coordinate(s)
            yi : float / array of floats, shape (l,)
                y Cartesian coordinate(s)
            zdata : array of floats, shape (n,)
                value at each point in the triangulation
                must be the same size of the mesh
            order : int (default=1)
                order of the interpolatory function used:
                    0 = nearest-neighbour,
                    1 = linear,
                    3 = cubic

        Returns:
            zi : float / array of floats, shape (l,)
                interpolates value(s) at (xi, yi)
            err : int / array of ints, shape (l,)
                whether interpolation (0), extrapolation (1) or error (other)
        &#34;&#34;&#34;

        if order == 0:
            return self.interpolate_nearest(xi, yi, zdata)
        elif order == 1:
            return self.interpolate_linear(xi, yi, zdata)
        elif order == 3:
            return self.interpolate_cubic(xi, yi, zdata)
        else:
            raise ValueError(&#34;order must be 0, 1, or 3&#34;)


    def interpolate_nearest(self, xi, yi, zdata):
        &#34;&#34;&#34;
        Nearest-neighbour interpolation.
        Calls nearnd to find the index of the closest neighbours to xi,yi

        Args:
            xi : float / array of floats, shape (l,)
                x coordinates on the Cartesian plane
            yi : float / array of floats, shape (l,)
                y coordinates on the Cartesian plane

        Returns:
            zi : float / array of floats, shape (l,)
                nearest-neighbour interpolated value(s) of (xi,yi)
            err : int / array of ints, shape (l,)
                whether interpolation (0), extrapolation (1) or error (other)
        &#34;&#34;&#34;
        if zdata.size != self.npoints:
            raise ValueError(&#39;zdata should be same size as mesh&#39;)

        xi = np.atleast_1d(xi)
        yi = np.atleast_1d(yi)

        size = xi.size

        zdata = self._shuffle_field(zdata)

        zierr = np.zeros(size, dtype=np.int32)
        ist = np.ones(size, dtype=np.int32)
        ist, dist = _tripack.nearnds(xi, yi, ist, self._x, self._y,
                                     self.lst, self.lptr, self.lend)

        # check if interpolation or extrapolation
        hull_idx = self.convex_hull()
        hull_pts = self.points[hull_idx]
        hull_x = hull_pts[:,0]
        hull_y = hull_pts[:,1]

        for i in range(0, zierr.size):
            vector_det = (hull_x[1:] - hull_x[:-1])*(yi[i] - hull_y[:-1]) - \
                         (hull_y[1:] - hull_y[:-1])*(xi[i] - hull_x[:-1])

            # if vector_det &gt; 0: within convex hull
            # if vector_det = 0: on top of convex hull
            # if vector_det &lt; 0: outside convex hull
            zierr[i] = (vector_det &lt; 0).any()

        return np.squeeze(zdata[ist - 1]), zierr


    def interpolate_linear(self, xi, yi, zdata):
        &#34;&#34;&#34;
        Piecewise linear interpolation / extrapolation to arbitrary point(s).
        The method is fast, but has only \\(C^0\\) continuity.

        Args:
            xi : float / array of floats, shape (l,)
                x coordinates on the Cartesian plane
            yi : float / array of floats, shape (l,)
                y coordinates on the Cartesian plane
            zdata : array of floats, shape (n,)
                value at each point in the triangulation
                must be the same size of the mesh

        Returns:
            zi : float / array of floats, shape (l,)
                interpolated value(s) of (xi,yi)
            err : int / array of ints, shape (l,)
                whether interpolation (0), extrapolation (1) or error (other)
        &#34;&#34;&#34;

        if zdata.size != self.npoints:
            raise ValueError(&#39;zdata should be same size as mesh&#39;)

        xi = np.atleast_1d(xi)
        yi = np.atleast_1d(yi)

        size = xi.size

        zi = np.empty(size)
        zierr = np.empty(size, dtype=np.int)

        zdata = self._shuffle_field(zdata)

        # iterate
        for i in range(0, size):
            ist = np.abs(self._x - xi[i]).argmin() + 1
            zi[i], zierr[i] = _srfpack.intrc0(xi[i], yi[i], self._x, self._y, zdata,\
                                       self.lst, self.lptr, self.lend, ist)

        return np.squeeze(zi), zierr


    def interpolate_cubic(self, xi, yi, zdata, gradz=None, derivatives=False):
        &#34;&#34;&#34;
        Cubic spline interpolation / extrapolation to arbirary point(s).
        This method has \\(C^1\\) continuity.

        Args:
            xi : float / array of floats, shape (l,)
                x coordinates on the Cartesian plane
            yi : float / array of floats, shape (l,)
                y coordinates on the Cartesian plane
            zdata : array of floats, shape (n,)
                value at each point in the triangulation
                must be the same size of the mesh
            gradz : array of floats, shape (2,n) (optional)
                derivative at each point in the triangulation in the
                - x-direction (first row),
                - y-direction (second row)
                if not supplied it is evaluated using `gradient()`
            derivatives : bool (default=False)
                optionally returns \\( \\frac{df}{dx} , \\frac{df}{dy} \\)
                the first derivatives at point(s) (xi,yi)

        Returns:
            zi : float / array of floats, shape (l,)
                interpolated value(s) of (xi,yi)
            err : int / array of ints, shape (l,)
                whether interpolation (0), extrapolation (1) or error (other)
            dzx, dzy (optional) : float, array of floats, shape(l,)
                first partial derivatives \\( \\partial f \\partial x , \\partial f \\partial y \\)
                at (xi,yi)
        &#34;&#34;&#34;

        if zdata.size != self.npoints:
            raise ValueError(&#39;zdata should be same size as mesh&#39;)

        if type(gradz) == type(None):
            gradX, gradY = self.gradient(zdata)
            gradX, gradY = self._shuffle_field(gradX, gradY)
        elif np.array(gradz).shape == (2,self.npoints):
            gradX, gradY = self._shuffle_field(gradz[0], gradz[1])
        else:
            raise ValueError(&#34;gradz must be of shape {}&#34;.format((2,self.npoints)))

        iflgs = 0
        dflag = 1
        sigma = 0.0


        xi = np.atleast_1d(xi)
        yi = np.atleast_1d(yi)

        size = xi.size

        zi = np.empty(size)
        dzx = np.empty(size)
        dzy = np.empty(size)
        zierr = np.empty(size, dtype=np.int)

        gradZ = np.vstack([gradX, gradY])
        zdata = self._shuffle_field(zdata)

        for i in range(0, size):
            ist = np.abs(self._x - xi[i]).argmin() + 1
            zi[i], dzx[i], dzy[i], zierr[i] = _srfpack.intrc1(xi[i], yi[i], self._x, self._y, zdata,\
                               self.lst, self.lptr, self.lend, iflgs, sigma, gradZ, dflag, ist)

        if derivatives:
            return np.squeeze(zi), zierr, (dzx, dzy)
        else:
            return np.squeeze(zi), zierr


    def neighbour_simplices(self):
        &#34;&#34;&#34;
        Get indices of neighbour simplices for each simplex.
        The kth neighbour is opposite to the kth vertex.
        For simplices at the boundary, -1 denotes no neighbour.
        &#34;&#34;&#34;
        nt, ltri, lct, ierr = _tripack.trlist(self.lst, self.lptr, self.lend, nrow=6)
        if ierr != 0:
            raise ValueError(&#39;ierr={} in trlist\n{}&#39;.format(ierr, _ier_codes[ierr]))
        return ltri.T[:nt,3:] - 1


    def neighbour_and_arc_simplices(self):
        &#34;&#34;&#34;
        Get indices of neighbour simplices for each simplex and arc indices.
        Identical to get_neighbour_simplices() but also returns an array
        of indices that reside on boundary hull, -1 denotes no neighbour.
        &#34;&#34;&#34;
        nt, ltri, lct, ierr = _tripack.trlist(self.lst, self.lptr, self.lend, nrow=9)
        if ierr != 0:
            raise ValueError(&#39;ierr={} in trlist\n{}&#39;.format(ierr, _ier_codes[ierr]))
        ltri = ltri.T[:nt] - 1
        return ltri[:,3:6], ltri[:,6:]


    def nearest_vertex(self, xi, yi):
        &#34;&#34;&#34;
        Locate the index of the nearest vertex to points (xi,yi)
        and return the squared distance between (xi,yi) and
        each nearest neighbour.

        Args:
            xi : array of floats, shape (l,)
                Cartesian coordinates in the x direction
            yi : array of floats, shape (l,)
                Cartesian coordinates in the y direction

        Returns:
            index : array of ints
                the nearest vertex to each of the supplied points
            dist : array of floats
                squared distance to the closest vertex identified

        Notes:
            Faster searches can be obtained using a KDTree.
            Store all x and y coordinates in a (c)KDTree, then query
            a set of points to find their nearest neighbours.
        &#34;&#34;&#34;
        n = np.array(xi).size
        xi = np.array(xi).reshape(n)
        yi = np.array(yi).reshape(n)

        idx  = np.empty_like(xi, dtype=np.int)
        dist = np.empty_like(xi, dtype=np.float)

        for pt in range(0, n):
            # i is the node at which we start the search
            # the closest x coordinate is a good place
            i = np.abs(self._x - xi[pt]).argmin()

            idx[pt], dist[pt] = _tripack.nearnd(xi[pt], yi[pt], i, self._x, self._y,\
                                                self.lst, self.lptr, self.lend)
        idx -= 1 # return to C ordering

        return self._deshuffle_simplices(idx), dist


    def containing_triangle(self, xi, yi):
        &#34;&#34;&#34;
        Returns indices of the triangles containing xi yi

        Args:
            xi : float / array of floats, shape (l,)
                Cartesian coordinates in the x direction
            yi : float / array of floats, shape (l,)
                Cartesian coordinates in the y direction

        Returns:
            tri_indices: array of ints, shape (l,)

        Notes:
            The simplices are found as `cartesian.Triangulation.simplices[tri_indices]`
        &#34;&#34;&#34;
        p = self._permutation
        pts = np.column_stack([xi, yi])

        sorted_simplices = np.sort(self._simplices, axis=1)

        triangles = []
        for pt in pts:
            t = _tripack.trfind(3, pt[0], pt[1], self._x, self._y, self.lst, self.lptr, self.lend)
            tri = np.sort(t) - 1

            triangles.extend(np.where(np.all(p[sorted_simplices]==p[tri], axis=1))[0])

        return np.array(triangles).ravel()


    def containing_simplex_and_bcc(self, xi, yi):
        &#34;&#34;&#34;
        Returns the simplices containing (xi,yi)
        and the local barycentric, normalised coordinates.

        Args:
            xi : float / array of floats, shape (l,)
               Cartesian coordinates in the x direction
            yi : float / array of floats, shape (l,)
               Cartesian coordinates in the y direction

        Returns:
            bcc : normalised barycentric coordinates
            tri : simplices containing (xi,yi)

        Notes:
            The ordering of the vertices may differ from that stored in
            `self.simplices` array but will still be a loop around the simplex.
        &#34;&#34;&#34;

        pts = np.column_stack([xi,yi])

        tri = np.empty((pts.shape[0], 3), dtype=np.int) # simplices
        bcc = np.empty_like(tri, dtype=np.float) # barycentric coords

        for i, pt in enumerate(pts):
            t = _tripack.trfind(3, pt[0], pt[1], self._x, self._y, self.lst, self.lptr, self.lend)
            tri[i] = t

            vert = self._points[tri[i] - 1]
            v0 = vert[1] - vert[0]
            v1 = vert[2] - vert[0]
            v2 = pt - vert[0]

            d00 = v0.dot(v0)
            d01 = v0.dot(v1)
            d11 = v1.dot(v1)
            d20 = v2.dot(v0)
            d21 = v2.dot(v1)
            denom = d00*d11 - d01*d01

            v = (d11 * d20 - d01 * d21) / denom
            w = (d00 * d21 - d01 * d20) / denom
            u = 1.0 - v - w

            bcc[i] = [u, v, w]

        tri -= 1 # return to C ordering

        bcc /= bcc.sum(axis=1).reshape(-1,1)

        return bcc, self._deshuffle_simplices(tri)


    def identify_vertex_neighbours(self, vertex):
        &#34;&#34;&#34;
        Find the neighbour-vertices in the triangulation for the given vertex
        Searches `self.simplices` for vertex entries and sorts neighbours
        &#34;&#34;&#34;
        simplices = self.simplices
        ridx, cidx = np.where(simplices == vertex)
        neighbour_array = np.unique(np.hstack([simplices[ridx]])).tolist()
        neighbour_array.remove(vertex)
        return neighbour_array



    def identify_vertex_triangles(self, vertices):
        &#34;&#34;&#34;
        Find all triangles which own any of the vertices in the list provided
        &#34;&#34;&#34;

        triangles = []

        for vertex in np.array(vertices).reshape(-1):
            triangles.append(np.where(self.simplices == vertex)[0])

        return np.unique(np.concatenate(triangles))


    def identify_segments(self):
        &#34;&#34;&#34;
        Find all the segments in the triangulation and return an
        array of vertices (n1,n2) where n1 &lt; n2
        &#34;&#34;&#34;

        i1 = np.sort([self._simplices[:,0], self._simplices[:,1]], axis=0)
        i2 = np.sort([self._simplices[:,0], self._simplices[:,2]], axis=0)
        i3 = np.sort([self._simplices[:,1], self._simplices[:,2]], axis=0)

        a = np.hstack([i1, i2, i3]).T

        # find unique rows in numpy array
        # &lt;http://stackoverflow.com/questions/16970982/find-unique-rows-in-numpy-array&gt;
        b = np.ascontiguousarray(a).view(np.dtype((np.void, a.dtype.itemsize * a.shape[1])))
        segments = np.unique(b).view(a.dtype).reshape(-1, a.shape[1])

        return self._deshuffle_simplices(segments)


    def segment_midpoints_by_vertices(self, vertices):
        &#34;&#34;&#34;
        Add midpoints to any segment connected to the vertices in the
        list / array provided.
        &#34;&#34;&#34;

        segments = set()

        for vertex in vertices:
            neighbours = self.identify_vertex_neighbours(vertex)
            segments.update( min( tuple((vertex, n1)), tuple((n1, vertex))) for n1 in neighbours )

        segs = np.array(list(segments))

        new_midpoints = self.segment_midpoints(segments=segs)

        return new_midpoints


    def face_midpoints(self, simplices=None):
        &#34;&#34;&#34;
        Identify the centroid of every simplex in the triangulation. If an array of
        simplices is given then the centroids of only those simplices is returned.
        &#34;&#34;&#34;

        if type(simplices) == type(None):
            simplices = self.simplices

        mids = self.points[simplices].mean(axis=1)
        mid_xpt, mid_ypt = mids[:,0], mids[:,1]

        return mid_xpt, mid_ypt


    def segment_midpoints(self, segments=None):
        &#34;&#34;&#34;
        Identify the midpoints of every line segment in the triangulation.
        If an array of segments of shape (no_of_segments,2) is given,
        then the midpoints of only those segments is returned.

        Notes:
            Segments in the array must not be duplicates or the re-triangulation
            will fail. Take care not to miss that (n1,n2) is equivalent to (n2,n1).
        &#34;&#34;&#34;

        if type(segments) == type(None):
            segments = self.identify_segments()
        points = self.points

        mids = (points[segments[:,0]] + points[segments[:,1]]) * 0.5
        mid_xpt, mid_ypt = mids[:,0], mids[:,1]

        return mid_xpt, mid_ypt


    def segment_tripoints(self, ratio=0.33333):
        &#34;&#34;&#34;
        Identify the trisection points of every line segment in the triangulation
        &#34;&#34;&#34;

        segments = self.identify_segments()
        points = self.points

        mids1 = ratio*points[segments[:,0]] + (1.0-ratio)*points[segments[:,1]]
        mids2 = (1.0-ratio)*points[segments[:,0]] + ratio*points[segments[:,1]]

        mids = np.vstack((mids1,mids2))
        mid_xpt, mid_ypt = mids[:,0], mids[:,1]

        return mid_xpt, mid_ypt


    def convex_hull(self):
        &#34;&#34;&#34;
        Find the Convex Hull of the internal set of x,y points.

        Returns:
            bnodes : array of ints
                indices corresponding to points on the convex hull
        &#34;&#34;&#34;
        bnodes, nb, na, nt = _tripack.bnodes(self.lst, self.lptr, self.lend, self.npoints)
        return self._deshuffle_simplices(bnodes[:nb] - 1)


    def areas(self):
        &#34;&#34;&#34;
        Compute the area of each triangle within the triangulation of points.

        Returns:
            area : array of floats, shape (nt,)
                area of each triangle in `self.simplices` where nt
                is the number of triangles.

        &#34;&#34;&#34;
        v1 = self.points[self.simplices[:,1]] - self.points[self.simplices[:,0]]
        v2 = self.points[self.simplices[:,2]] - self.points[self.simplices[:,1]]

        area = 0.5*(v1[:,0]*v2[:,1] - v1[:,1]*v2[:,0])
        return area


    def edge_lengths(self):
        &#34;&#34;&#34;
        Compute the edge-lengths of each triangle in the triangulation.
        &#34;&#34;&#34;
        simplex = self.simplices.T

        # simplex is vectors a, b, c defining the corners
        a = self.points[simplex[0]]
        b = self.points[simplex[1]]
        c = self.points[simplex[2]]

        # norm to calculate length
        ab = np.linalg.norm(b - a, axis=1)
        bc = np.linalg.norm(c - a, axis=1)
        ac = np.linalg.norm(a - c, axis=1)

        return ab, bc, ac


    def _add_midpoints(self):

        mid_xpt, mid_ypt = self.segment_midpoints()

        x_v2 = np.concatenate([self.x, mid_xpt], axis=0)
        y_v2 = np.concatenate([self.y, mid_ypt], axis=0)

        return x_v2, y_v2

    def _add_tripoints(self, ratio=0.333333):

        mid_xpt, mid_ypt = self.segment_tripoints()

        x_v2 = np.concatenate([self.x, mid_xpt], axis=0)
        y_v2 = np.concatenate([self.y, mid_ypt], axis=0)

        return x_v2, y_v2

    def _add_face_centroids(self):

        face_xpt, face_ypt = self.face_midpoints()

        x_v2 = np.concatenate((self.x, face_xpt), axis=0)
        y_v2 = np.concatenate((self.y, face_ypt), axis=0)

        return x_v2, y_v2


    def uniformly_refine_triangulation(self, faces=False, trisect=False):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation
        &#34;&#34;&#34;

        if faces:
            x_v1, y_v1 = self._add_face_centroids()

        else:
            if not trisect:
                x_v1, y_v1 = self._add_midpoints()
            else:
                x_v1, y_v1 = self._add_tripoints(ratio=0.333333)

        return x_v1, y_v1


    def midpoint_refine_triangulation_by_vertices(self, vertices):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation connected to any of the vertices in the list provided
        &#34;&#34;&#34;

        xi, yi = self.segment_midpoints_by_vertices(vertices=vertices)

        x_v1 = np.concatenate((self.x, xi), axis=0)
        y_v1 = np.concatenate((self.y, yi), axis=0)

        return x_v1, y_v1


    def edge_refine_triangulation_by_triangles(self, triangles):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation that are associated with the triangles in the list
        of indices provided.

        Notes:
            The triangles are here represented as a single index.
            The vertices of triangle `i` are given by `self.simplices[i]`.
        &#34;&#34;&#34;

        ## Note there should be no duplicates in the list of triangles
        ## but because we remove duplicates from the list of all segments,
        ## there is no pressing need to check this.

        # identify the segments

        simplices = self.simplices
        segments = set()

        for index in np.array(triangles).reshape(-1):
            tri = simplices[index]
            segments.add( min( tuple((tri[0], tri[1])), tuple((tri[0], tri[1]))) )
            segments.add( min( tuple((tri[1], tri[2])), tuple((tri[2], tri[1]))) )
            segments.add( min( tuple((tri[0], tri[2])), tuple((tri[2], tri[0]))) )

        segs = np.array(list(segments))

        xi, yi = self.segment_midpoints(segs)

        x_v1 = np.concatenate((self.x, xi), axis=0)
        y_v1 = np.concatenate((self.y, yi), axis=0)

        return x_v1, y_v1


    def edge_refine_triangulation_by_vertices(self, vertices):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation connected to any of the vertices in the list provided
        &#34;&#34;&#34;

        triangles = self.identify_vertex_triangles(vertices)

        return self.edge_refine_triangulation_by_triangles(triangles)


    def centroid_refine_triangulation_by_triangles(self, triangles):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation that are associated with the triangles in the list provided.

        Notes:
            The triangles are here represented as a single index.
            The vertices of triangle `i` are given by `self.simplices[i]`.
        &#34;&#34;&#34;

        # Remove duplicates from the list of triangles

        triangles = np.unique(np.array(triangles))

        xi, yi = self.face_midpoints(simplices=self.simplices[triangles])

        x_v1 = np.concatenate((self.x, xi), axis=0)
        y_v1 = np.concatenate((self.y, yi), axis=0)

        return x_v1, y_v1


    def centroid_refine_triangulation_by_vertices(self, vertices):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation connected to any of the vertices in the list provided
        &#34;&#34;&#34;

        triangles = self.identify_vertex_triangles(vertices)

        return self.centroid_refine_triangulation_by_triangles(triangles)


    def join(self, t2, unique=False):
        &#34;&#34;&#34;
        Join this triangulation with another. If the points are known to have no duplicates, then
        set unique=False to skip the testing and duplicate removal
        &#34;&#34;&#34;

        x_v1 = np.concatenate((self.x, t2.x), axis=0)
        y_v1 = np.concatenate((self.y, t2.y), axis=0)

        ## remove any duplicates

        if not unique:
            a = np.ascontiguousarray(np.vstack((x_v1, y_v1)).T)
            unique_a = np.unique(a.view([(&#39;&#39;, a.dtype)]*a.shape[1]))
            unique_coords = unique_a.view(a.dtype).reshape((unique_a.shape[0], a.shape[1]))

            x_v1 = unique_coords[:,0]
            y_v1 = unique_coords[:,1]

        return x_v1, y_v1


    def _build_cKDtree(self):

        try:
            import scipy.spatial
            self._cKDtree = scipy.spatial.cKDTree(self.points)

        except:
            self._cKDtree = None


    def nearest_vertices(self, x, y, k=1, max_distance=np.inf ):
        &#34;&#34;&#34;
        Query the cKDtree for the nearest neighbours and Euclidean
        distance from x,y points.

        Returns 0, 0 if a cKDtree has not been constructed
        (switch `tree=True` if you need this routine)

        Args:
            x : 1D array of Cartesian x coordinates
            y : 1D array of Cartesian y coordinates
            k : int (defaul=1)
                number of nearest neighbours to return
            max_distance : float (default: inf)
                maximum Euclidean distance to search for neighbours

        Returns:
            d : array of floats
                Euclidean distance between each point and their
                nearest neighbour(s)
            vert : array of ints
                vertices of the nearest neighbour(s)
        &#34;&#34;&#34;

        if self.tree == False or self.tree == None:
            return 0, 0

        xy = np.column_stack([x, y])

        dxy, vertices = self._cKDtree.query(xy, k=k, distance_upper_bound=max_distance)


        if k == 1:   # force this to be a 2D array
            vertices = np.reshape(vertices, (-1, 1))

        return dxy, vertices</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="stripy.cartesian_meshes.square_border" href="cartesian_meshes.html#stripy.cartesian_meshes.square_border">square_border</a></li>
<li><a title="stripy.cartesian_meshes.square_mesh" href="cartesian_meshes.html#stripy.cartesian_meshes.square_mesh">square_mesh</a></li>
<li><a title="stripy.cartesian_meshes.elliptical_mesh" href="cartesian_meshes.html#stripy.cartesian_meshes.elliptical_mesh">elliptical_mesh</a></li>
<li><a title="stripy.cartesian_meshes.random_mesh" href="cartesian_meshes.html#stripy.cartesian_meshes.random_mesh">random_mesh</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="stripy.cartesian.Triangulation.points"><code class="name">var <span class="ident">points</span></code></dt>
<dd>
<section class="desc"><p>Stored Cartesian xy coordinates from triangulation</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def points(self):
    &#34;&#34;&#34; Stored Cartesian xy coordinates from triangulation &#34;&#34;&#34;
    return self._deshuffle_field(self._points)</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.simplices"><code class="name">var <span class="ident">simplices</span></code></dt>
<dd>
<section class="desc"><p>Indices of the points forming the simplices in the triangulation.
Points are ordered anticlockwise</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def simplices(self):
    &#34;&#34;&#34; Indices of the points forming the simplices in the triangulation.
    Points are ordered anticlockwise &#34;&#34;&#34;
    return self._deshuffle_simplices(self._simplices)</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.x"><code class="name">var <span class="ident">x</span></code></dt>
<dd>
<section class="desc"><p>Stored Cartesian x coordinates from triangulation</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def x(self):
    &#34;&#34;&#34; Stored Cartesian x coordinates from triangulation &#34;&#34;&#34;
    return self._deshuffle_field(self._x)</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.y"><code class="name">var <span class="ident">y</span></code></dt>
<dd>
<section class="desc"><p>Stored Cartesian y coordinates from triangulation</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def y(self):
    &#34;&#34;&#34; Stored Cartesian y coordinates from triangulation &#34;&#34;&#34;
    return self._deshuffle_field(self._y)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="stripy.cartesian.Triangulation.areas"><code class="name flex">
<span>def <span class="ident">areas</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute the area of each triangle within the triangulation of points.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>area</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>nt</code>,)</dt>
<dd>area of each triangle in <code>self.simplices</code> where nt
is the number of triangles.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def areas(self):
    &#34;&#34;&#34;
    Compute the area of each triangle within the triangulation of points.

    Returns:
        area : array of floats, shape (nt,)
            area of each triangle in `self.simplices` where nt
            is the number of triangles.

    &#34;&#34;&#34;
    v1 = self.points[self.simplices[:,1]] - self.points[self.simplices[:,0]]
    v2 = self.points[self.simplices[:,2]] - self.points[self.simplices[:,1]]

    area = 0.5*(v1[:,0]*v2[:,1] - v1[:,1]*v2[:,0])
    return area</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.centroid_refine_triangulation_by_triangles"><code class="name flex">
<span>def <span class="ident">centroid_refine_triangulation_by_triangles</span></span>(<span>self, triangles)</span>
</code></dt>
<dd>
<section class="desc"><p>return points defining a refined triangulation obtained by bisection of all edges
in the triangulation that are associated with the triangles in the list provided.</p>
<h2 id="notes">Notes</h2>
<p>The triangles are here represented as a single index.
The vertices of triangle <code>i</code> are given by <code>self.simplices[i]</code>.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def centroid_refine_triangulation_by_triangles(self, triangles):
    &#34;&#34;&#34;
    return points defining a refined triangulation obtained by bisection of all edges
    in the triangulation that are associated with the triangles in the list provided.

    Notes:
        The triangles are here represented as a single index.
        The vertices of triangle `i` are given by `self.simplices[i]`.
    &#34;&#34;&#34;

    # Remove duplicates from the list of triangles

    triangles = np.unique(np.array(triangles))

    xi, yi = self.face_midpoints(simplices=self.simplices[triangles])

    x_v1 = np.concatenate((self.x, xi), axis=0)
    y_v1 = np.concatenate((self.y, yi), axis=0)

    return x_v1, y_v1</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.centroid_refine_triangulation_by_vertices"><code class="name flex">
<span>def <span class="ident">centroid_refine_triangulation_by_vertices</span></span>(<span>self, vertices)</span>
</code></dt>
<dd>
<section class="desc"><p>return points defining a refined triangulation obtained by bisection of all edges
in the triangulation connected to any of the vertices in the list provided</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def centroid_refine_triangulation_by_vertices(self, vertices):
    &#34;&#34;&#34;
    return points defining a refined triangulation obtained by bisection of all edges
    in the triangulation connected to any of the vertices in the list provided
    &#34;&#34;&#34;

    triangles = self.identify_vertex_triangles(vertices)

    return self.centroid_refine_triangulation_by_triangles(triangles)</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.containing_simplex_and_bcc"><code class="name flex">
<span>def <span class="ident">containing_simplex_and_bcc</span></span>(<span>self, xi, yi)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the simplices containing (xi,yi)
and the local barycentric, normalised coordinates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xi</code></strong> :&ensp;<code>float</code> / <code>array</code> of <code>floats</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>&nbsp;</dd>
<dt>Cartesian coordinates in the x direction</dt>
<dt><strong><code>yi</code></strong> :&ensp;<code>float</code> / <code>array</code> of <code>floats</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>&nbsp;</dd>
</dl>
<p>Cartesian coordinates in the y direction</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bcc</code></strong> :&ensp;<code>normalised</code> <code>barycentric</code> <code>coordinates</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>tri</code></strong> :&ensp;<code>simplices</code> <code>containing</code> (<code>xi</code>,<code>yi</code>)</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The ordering of the vertices may differ from that stored in
<code>self.simplices</code> array but will still be a loop around the simplex.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def containing_simplex_and_bcc(self, xi, yi):
    &#34;&#34;&#34;
    Returns the simplices containing (xi,yi)
    and the local barycentric, normalised coordinates.

    Args:
        xi : float / array of floats, shape (l,)
           Cartesian coordinates in the x direction
        yi : float / array of floats, shape (l,)
           Cartesian coordinates in the y direction

    Returns:
        bcc : normalised barycentric coordinates
        tri : simplices containing (xi,yi)

    Notes:
        The ordering of the vertices may differ from that stored in
        `self.simplices` array but will still be a loop around the simplex.
    &#34;&#34;&#34;

    pts = np.column_stack([xi,yi])

    tri = np.empty((pts.shape[0], 3), dtype=np.int) # simplices
    bcc = np.empty_like(tri, dtype=np.float) # barycentric coords

    for i, pt in enumerate(pts):
        t = _tripack.trfind(3, pt[0], pt[1], self._x, self._y, self.lst, self.lptr, self.lend)
        tri[i] = t

        vert = self._points[tri[i] - 1]
        v0 = vert[1] - vert[0]
        v1 = vert[2] - vert[0]
        v2 = pt - vert[0]

        d00 = v0.dot(v0)
        d01 = v0.dot(v1)
        d11 = v1.dot(v1)
        d20 = v2.dot(v0)
        d21 = v2.dot(v1)
        denom = d00*d11 - d01*d01

        v = (d11 * d20 - d01 * d21) / denom
        w = (d00 * d21 - d01 * d20) / denom
        u = 1.0 - v - w

        bcc[i] = [u, v, w]

    tri -= 1 # return to C ordering

    bcc /= bcc.sum(axis=1).reshape(-1,1)

    return bcc, self._deshuffle_simplices(tri)</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.containing_triangle"><code class="name flex">
<span>def <span class="ident">containing_triangle</span></span>(<span>self, xi, yi)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns indices of the triangles containing xi yi</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xi</code></strong> :&ensp;<code>float</code> / <code>array</code> of <code>floats</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>Cartesian coordinates in the x direction</dd>
<dt><strong><code>yi</code></strong> :&ensp;<code>float</code> / <code>array</code> of <code>floats</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>Cartesian coordinates in the y direction</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>tri_indices</code></strong></dt>
<dd>array of ints, shape (l,)</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The simplices are found as <code>cartesian.Triangulation.simplices[tri_indices]</code></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def containing_triangle(self, xi, yi):
    &#34;&#34;&#34;
    Returns indices of the triangles containing xi yi

    Args:
        xi : float / array of floats, shape (l,)
            Cartesian coordinates in the x direction
        yi : float / array of floats, shape (l,)
            Cartesian coordinates in the y direction

    Returns:
        tri_indices: array of ints, shape (l,)

    Notes:
        The simplices are found as `cartesian.Triangulation.simplices[tri_indices]`
    &#34;&#34;&#34;
    p = self._permutation
    pts = np.column_stack([xi, yi])

    sorted_simplices = np.sort(self._simplices, axis=1)

    triangles = []
    for pt in pts:
        t = _tripack.trfind(3, pt[0], pt[1], self._x, self._y, self.lst, self.lptr, self.lend)
        tri = np.sort(t) - 1

        triangles.extend(np.where(np.all(p[sorted_simplices]==p[tri], axis=1))[0])

    return np.array(triangles).ravel()</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.convex_hull"><code class="name flex">
<span>def <span class="ident">convex_hull</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Find the Convex Hull of the internal set of x,y points.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bnodes</code></strong> :&ensp;<code>array</code> of <code>ints</code></dt>
<dd>indices corresponding to points on the convex hull</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def convex_hull(self):
    &#34;&#34;&#34;
    Find the Convex Hull of the internal set of x,y points.

    Returns:
        bnodes : array of ints
            indices corresponding to points on the convex hull
    &#34;&#34;&#34;
    bnodes, nb, na, nt = _tripack.bnodes(self.lst, self.lptr, self.lend, self.npoints)
    return self._deshuffle_simplices(bnodes[:nb] - 1)</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.edge_lengths"><code class="name flex">
<span>def <span class="ident">edge_lengths</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute the edge-lengths of each triangle in the triangulation.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def edge_lengths(self):
    &#34;&#34;&#34;
    Compute the edge-lengths of each triangle in the triangulation.
    &#34;&#34;&#34;
    simplex = self.simplices.T

    # simplex is vectors a, b, c defining the corners
    a = self.points[simplex[0]]
    b = self.points[simplex[1]]
    c = self.points[simplex[2]]

    # norm to calculate length
    ab = np.linalg.norm(b - a, axis=1)
    bc = np.linalg.norm(c - a, axis=1)
    ac = np.linalg.norm(a - c, axis=1)

    return ab, bc, ac</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.edge_refine_triangulation_by_triangles"><code class="name flex">
<span>def <span class="ident">edge_refine_triangulation_by_triangles</span></span>(<span>self, triangles)</span>
</code></dt>
<dd>
<section class="desc"><p>return points defining a refined triangulation obtained by bisection of all edges
in the triangulation that are associated with the triangles in the list
of indices provided.</p>
<h2 id="notes">Notes</h2>
<p>The triangles are here represented as a single index.
The vertices of triangle <code>i</code> are given by <code>self.simplices[i]</code>.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def edge_refine_triangulation_by_triangles(self, triangles):
    &#34;&#34;&#34;
    return points defining a refined triangulation obtained by bisection of all edges
    in the triangulation that are associated with the triangles in the list
    of indices provided.

    Notes:
        The triangles are here represented as a single index.
        The vertices of triangle `i` are given by `self.simplices[i]`.
    &#34;&#34;&#34;

    ## Note there should be no duplicates in the list of triangles
    ## but because we remove duplicates from the list of all segments,
    ## there is no pressing need to check this.

    # identify the segments

    simplices = self.simplices
    segments = set()

    for index in np.array(triangles).reshape(-1):
        tri = simplices[index]
        segments.add( min( tuple((tri[0], tri[1])), tuple((tri[0], tri[1]))) )
        segments.add( min( tuple((tri[1], tri[2])), tuple((tri[2], tri[1]))) )
        segments.add( min( tuple((tri[0], tri[2])), tuple((tri[2], tri[0]))) )

    segs = np.array(list(segments))

    xi, yi = self.segment_midpoints(segs)

    x_v1 = np.concatenate((self.x, xi), axis=0)
    y_v1 = np.concatenate((self.y, yi), axis=0)

    return x_v1, y_v1</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.edge_refine_triangulation_by_vertices"><code class="name flex">
<span>def <span class="ident">edge_refine_triangulation_by_vertices</span></span>(<span>self, vertices)</span>
</code></dt>
<dd>
<section class="desc"><p>return points defining a refined triangulation obtained by bisection of all edges
in the triangulation connected to any of the vertices in the list provided</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def edge_refine_triangulation_by_vertices(self, vertices):
    &#34;&#34;&#34;
    return points defining a refined triangulation obtained by bisection of all edges
    in the triangulation connected to any of the vertices in the list provided
    &#34;&#34;&#34;

    triangles = self.identify_vertex_triangles(vertices)

    return self.edge_refine_triangulation_by_triangles(triangles)</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.face_midpoints"><code class="name flex">
<span>def <span class="ident">face_midpoints</span></span>(<span>self, simplices=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Identify the centroid of every simplex in the triangulation. If an array of
simplices is given then the centroids of only those simplices is returned.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def face_midpoints(self, simplices=None):
    &#34;&#34;&#34;
    Identify the centroid of every simplex in the triangulation. If an array of
    simplices is given then the centroids of only those simplices is returned.
    &#34;&#34;&#34;

    if type(simplices) == type(None):
        simplices = self.simplices

    mids = self.points[simplices].mean(axis=1)
    mid_xpt, mid_ypt = mids[:,0], mids[:,1]

    return mid_xpt, mid_ypt</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.gradient"><code class="name flex">
<span>def <span class="ident">gradient</span></span>(<span>self, f, nit=3, tol=0.001, guarantee_convergence=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the gradient of an n-dimensional array.</p>
<p>The method consists of minimizing a quadratic functional Q(G) over
gradient vectors (in x and y directions), where Q is an approximation
to the linearized curvature over the triangulation of a C-1 bivariate
function (F(x,y)) which interpolates the nodal values and gradients.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>field over which to evaluate the gradient</dd>
<dt><strong><code>nit</code></strong> :&ensp;<code>int</code> (default: <code>3</code>)</dt>
<dd>number of iterations to reach a convergence tolerance,
tol nit &gt;= 1</dd>
<dt><strong><code>tol</code></strong></dt>
<dd>float (default: 1e-3)
maximum change in gradient between iterations.
convergence is reached when this condition is met.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dfdx</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>derivative of f in the x direction</dd>
<dt><strong><code>dfdy</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>derivative of f in the y direction</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>For SIGMA = 0, optimal efficiency was achieved in testing with
tol = 0, and nit = 3 or 4.</p>
<p>The restriction of F to an arc of the triangulation is taken to be
the Hermite interpolatory tension spline defined by the data values
and tangential gradient components at the endpoints of the arc, and
Q is the sum over the triangulation arcs, excluding interior
constraint arcs, of the linearized curvatures of F along the arcs &ndash;
the integrals over the arcs of ( (d^2 F / dT^2)^2), where ( d^2 F / dT^2)is the second
derivative of (F) with respect to distance (T) along the arc.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def gradient(self, f, nit=3, tol=1e-3, guarantee_convergence=False):
    &#34;&#34;&#34;
    Return the gradient of an n-dimensional array.

    The method consists of minimizing a quadratic functional Q(G) over
    gradient vectors (in x and y directions), where Q is an approximation
    to the linearized curvature over the triangulation of a C-1 bivariate
    function \\(F(x,y)\\) which interpolates the nodal values and gradients.

    Args:
        f : array of floats, shape (n,)
            field over which to evaluate the gradient
        nit : int (default: 3)
            number of iterations to reach a convergence tolerance,
            tol nit &gt;= 1
        tol: float (default: 1e-3)
            maximum change in gradient between iterations.
            convergence is reached when this condition is met.

    Returns:
        dfdx : array of floats, shape (n,)
            derivative of f in the x direction
        dfdy : array of floats, shape (n,)
            derivative of f in the y direction

    Notes:
        For SIGMA = 0, optimal efficiency was achieved in testing with
        tol = 0, and nit = 3 or 4.

        The restriction of F to an arc of the triangulation is taken to be
        the Hermite interpolatory tension spline defined by the data values
        and tangential gradient components at the endpoints of the arc, and
        Q is the sum over the triangulation arcs, excluding interior
        constraint arcs, of the linearized curvatures of F along the arcs --
        the integrals over the arcs of \\( (d^2 F / dT^2)^2\\), where \\( d^2 F / dT^2\\)is the second
        derivative of \\(F\\) with respect to distance \\(T\\) along the arc.
    &#34;&#34;&#34;
    if f.size != self.npoints:
        raise ValueError(&#39;f should be the same size as mesh&#39;)

    gradient = np.zeros((2,self.npoints), order=&#39;F&#39;, dtype=np.float32)
    sigma = 0
    iflgs = 0

    f = self._shuffle_field(f)

    ierr = 1
    while ierr == 1:
        ierr = _srfpack.gradg(self._x, self._y, f, self.lst, self.lptr, self.lend,\
                              iflgs, sigma, gradient, nit=nit, dgmax=tol)
        if not guarantee_convergence:
            break

    if ierr &lt; 0:
        raise ValueError(&#39;ierr={} in gradg\n{}&#39;.format(ierr, _ier_codes[ierr]))

    return self._deshuffle_field(gradient[0], gradient[1])</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.gradient_local"><code class="name flex">
<span>def <span class="ident">gradient_local</span></span>(<span>self, f, index)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the gradient at a specified node.</p>
<p>This routine employs a local method, in which values depend only on nearby
data points, to compute an estimated gradient at a node.</p>
<p><code>gradient_local()</code> is more efficient than <code>gradient()</code> only if it is unnecessary
to compute gradients at all of the nodes. Both routines have similar accuracy.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def gradient_local(self, f, index):
    &#34;&#34;&#34;
    Return the gradient at a specified node.

    This routine employs a local method, in which values depend only on nearby
    data points, to compute an estimated gradient at a node.

    `gradient_local()` is more efficient than `gradient()` only if it is unnecessary
    to compute gradients at all of the nodes. Both routines have similar accuracy.
    &#34;&#34;&#34;
    if f.size != self.npoints:
        raise ValueError(&#39;f should be the same size as mesh&#39;)

    f = self._shuffle_field(f)


    gradX, gradY, l = _srfpack.gradl(index + 1, self._x, self._y, f,\
                                     self.lst, self.lptr, self.lend)

    return gradX, gradY</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.identify_segments"><code class="name flex">
<span>def <span class="ident">identify_segments</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Find all the segments in the triangulation and return an
array of vertices (n1,n2) where n1 &lt; n2</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def identify_segments(self):
    &#34;&#34;&#34;
    Find all the segments in the triangulation and return an
    array of vertices (n1,n2) where n1 &lt; n2
    &#34;&#34;&#34;

    i1 = np.sort([self._simplices[:,0], self._simplices[:,1]], axis=0)
    i2 = np.sort([self._simplices[:,0], self._simplices[:,2]], axis=0)
    i3 = np.sort([self._simplices[:,1], self._simplices[:,2]], axis=0)

    a = np.hstack([i1, i2, i3]).T

    # find unique rows in numpy array
    # &lt;http://stackoverflow.com/questions/16970982/find-unique-rows-in-numpy-array&gt;
    b = np.ascontiguousarray(a).view(np.dtype((np.void, a.dtype.itemsize * a.shape[1])))
    segments = np.unique(b).view(a.dtype).reshape(-1, a.shape[1])

    return self._deshuffle_simplices(segments)</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.identify_vertex_neighbours"><code class="name flex">
<span>def <span class="ident">identify_vertex_neighbours</span></span>(<span>self, vertex)</span>
</code></dt>
<dd>
<section class="desc"><p>Find the neighbour-vertices in the triangulation for the given vertex
Searches <code>self.simplices</code> for vertex entries and sorts neighbours</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def identify_vertex_neighbours(self, vertex):
    &#34;&#34;&#34;
    Find the neighbour-vertices in the triangulation for the given vertex
    Searches `self.simplices` for vertex entries and sorts neighbours
    &#34;&#34;&#34;
    simplices = self.simplices
    ridx, cidx = np.where(simplices == vertex)
    neighbour_array = np.unique(np.hstack([simplices[ridx]])).tolist()
    neighbour_array.remove(vertex)
    return neighbour_array</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.identify_vertex_triangles"><code class="name flex">
<span>def <span class="ident">identify_vertex_triangles</span></span>(<span>self, vertices)</span>
</code></dt>
<dd>
<section class="desc"><p>Find all triangles which own any of the vertices in the list provided</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def identify_vertex_triangles(self, vertices):
    &#34;&#34;&#34;
    Find all triangles which own any of the vertices in the list provided
    &#34;&#34;&#34;

    triangles = []

    for vertex in np.array(vertices).reshape(-1):
        triangles.append(np.where(self.simplices == vertex)[0])

    return np.unique(np.concatenate(triangles))</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.interpolate"><code class="name flex">
<span>def <span class="ident">interpolate</span></span>(<span>self, xi, yi, zdata, order=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Base class to handle nearest neighbour, linear, and cubic interpolation.
Given a triangulation of a set of nodes and values at the nodes,
this method interpolates the value at the given xi,yi coordinates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xi</code></strong> :&ensp;<code>float</code> / <code>array</code> of <code>floats</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>x Cartesian coordinate(s)</dd>
<dt><strong><code>yi</code></strong> :&ensp;<code>float</code> / <code>array</code> of <code>floats</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>y Cartesian coordinate(s)</dd>
<dt><strong><code>zdata</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>value at each point in the triangulation
must be the same size of the mesh</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>int</code> (default=<code>1</code>)</dt>
<dd>order of the interpolatory function used:
0 = nearest-neighbour,
1 = linear,
3 = cubic</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>zi</code></strong> :&ensp;<code>float</code> / <code>array</code> of <code>floats</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>interpolates value(s) at (xi, yi)</dd>
<dt><strong><code>err</code></strong> :&ensp;<code>int</code> / <code>array</code> of <code>ints</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>whether interpolation (0), extrapolation (1) or error (other)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def interpolate(self, xi, yi, zdata, order=1):
    &#34;&#34;&#34;
    Base class to handle nearest neighbour, linear, and cubic interpolation.
    Given a triangulation of a set of nodes and values at the nodes,
    this method interpolates the value at the given xi,yi coordinates.

    Args:
        xi : float / array of floats, shape (l,)
            x Cartesian coordinate(s)
        yi : float / array of floats, shape (l,)
            y Cartesian coordinate(s)
        zdata : array of floats, shape (n,)
            value at each point in the triangulation
            must be the same size of the mesh
        order : int (default=1)
            order of the interpolatory function used:
                0 = nearest-neighbour,
                1 = linear,
                3 = cubic

    Returns:
        zi : float / array of floats, shape (l,)
            interpolates value(s) at (xi, yi)
        err : int / array of ints, shape (l,)
            whether interpolation (0), extrapolation (1) or error (other)
    &#34;&#34;&#34;

    if order == 0:
        return self.interpolate_nearest(xi, yi, zdata)
    elif order == 1:
        return self.interpolate_linear(xi, yi, zdata)
    elif order == 3:
        return self.interpolate_cubic(xi, yi, zdata)
    else:
        raise ValueError(&#34;order must be 0, 1, or 3&#34;)</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.interpolate_cubic"><code class="name flex">
<span>def <span class="ident">interpolate_cubic</span></span>(<span>self, xi, yi, zdata, gradz=None, derivatives=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Cubic spline interpolation / extrapolation to arbirary point(s).
This method has (C^1) continuity.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xi</code></strong> :&ensp;<code>float</code> / <code>array</code> of <code>floats</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>x coordinates on the Cartesian plane</dd>
<dt><strong><code>yi</code></strong> :&ensp;<code>float</code> / <code>array</code> of <code>floats</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>y coordinates on the Cartesian plane</dd>
<dt><strong><code>zdata</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>value at each point in the triangulation
must be the same size of the mesh</dd>
<dt><strong><code>gradz</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>2</code>,<code>n</code>) (optional)</dt>
<dd>derivative at each point in the triangulation in the
- x-direction (first row),
- y-direction (second row)
if not supplied it is evaluated using <code>gradient()</code></dd>
<dt><strong><code>derivatives</code></strong> :&ensp;<code>bool</code> (default=<code>False</code>)</dt>
<dd>optionally returns ( \frac{df}{dx} , \frac{df}{dy} )
the first derivatives at point(s) (xi,yi)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>zi</code></strong> :&ensp;<code>float</code> / <code>array</code> of <code>floats</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>interpolated value(s) of (xi,yi)</dd>
<dt><strong><code>err</code></strong> :&ensp;<code>int</code> / <code>array</code> of <code>ints</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>whether interpolation (0), extrapolation (1) or error (other)</dd>
<dt><code>dzx</code>, <code>dzy</code> (optional) : <code>float</code>, <code>array</code> of <code>floats</code>, <code>shape</code>(<code>l</code>,)</dt>
<dd>first partial derivatives ( \partial f \partial x , \partial f \partial y )
at (xi,yi)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def interpolate_cubic(self, xi, yi, zdata, gradz=None, derivatives=False):
    &#34;&#34;&#34;
    Cubic spline interpolation / extrapolation to arbirary point(s).
    This method has \\(C^1\\) continuity.

    Args:
        xi : float / array of floats, shape (l,)
            x coordinates on the Cartesian plane
        yi : float / array of floats, shape (l,)
            y coordinates on the Cartesian plane
        zdata : array of floats, shape (n,)
            value at each point in the triangulation
            must be the same size of the mesh
        gradz : array of floats, shape (2,n) (optional)
            derivative at each point in the triangulation in the
            - x-direction (first row),
            - y-direction (second row)
            if not supplied it is evaluated using `gradient()`
        derivatives : bool (default=False)
            optionally returns \\( \\frac{df}{dx} , \\frac{df}{dy} \\)
            the first derivatives at point(s) (xi,yi)

    Returns:
        zi : float / array of floats, shape (l,)
            interpolated value(s) of (xi,yi)
        err : int / array of ints, shape (l,)
            whether interpolation (0), extrapolation (1) or error (other)
        dzx, dzy (optional) : float, array of floats, shape(l,)
            first partial derivatives \\( \\partial f \\partial x , \\partial f \\partial y \\)
            at (xi,yi)
    &#34;&#34;&#34;

    if zdata.size != self.npoints:
        raise ValueError(&#39;zdata should be same size as mesh&#39;)

    if type(gradz) == type(None):
        gradX, gradY = self.gradient(zdata)
        gradX, gradY = self._shuffle_field(gradX, gradY)
    elif np.array(gradz).shape == (2,self.npoints):
        gradX, gradY = self._shuffle_field(gradz[0], gradz[1])
    else:
        raise ValueError(&#34;gradz must be of shape {}&#34;.format((2,self.npoints)))

    iflgs = 0
    dflag = 1
    sigma = 0.0


    xi = np.atleast_1d(xi)
    yi = np.atleast_1d(yi)

    size = xi.size

    zi = np.empty(size)
    dzx = np.empty(size)
    dzy = np.empty(size)
    zierr = np.empty(size, dtype=np.int)

    gradZ = np.vstack([gradX, gradY])
    zdata = self._shuffle_field(zdata)

    for i in range(0, size):
        ist = np.abs(self._x - xi[i]).argmin() + 1
        zi[i], dzx[i], dzy[i], zierr[i] = _srfpack.intrc1(xi[i], yi[i], self._x, self._y, zdata,\
                           self.lst, self.lptr, self.lend, iflgs, sigma, gradZ, dflag, ist)

    if derivatives:
        return np.squeeze(zi), zierr, (dzx, dzy)
    else:
        return np.squeeze(zi), zierr</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.interpolate_linear"><code class="name flex">
<span>def <span class="ident">interpolate_linear</span></span>(<span>self, xi, yi, zdata)</span>
</code></dt>
<dd>
<section class="desc"><p>Piecewise linear interpolation / extrapolation to arbitrary point(s).
The method is fast, but has only (C^0) continuity.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xi</code></strong> :&ensp;<code>float</code> / <code>array</code> of <code>floats</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>x coordinates on the Cartesian plane</dd>
<dt><strong><code>yi</code></strong> :&ensp;<code>float</code> / <code>array</code> of <code>floats</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>y coordinates on the Cartesian plane</dd>
<dt><strong><code>zdata</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>value at each point in the triangulation
must be the same size of the mesh</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>zi</code></strong> :&ensp;<code>float</code> / <code>array</code> of <code>floats</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>interpolated value(s) of (xi,yi)</dd>
<dt><strong><code>err</code></strong> :&ensp;<code>int</code> / <code>array</code> of <code>ints</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>whether interpolation (0), extrapolation (1) or error (other)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def interpolate_linear(self, xi, yi, zdata):
    &#34;&#34;&#34;
    Piecewise linear interpolation / extrapolation to arbitrary point(s).
    The method is fast, but has only \\(C^0\\) continuity.

    Args:
        xi : float / array of floats, shape (l,)
            x coordinates on the Cartesian plane
        yi : float / array of floats, shape (l,)
            y coordinates on the Cartesian plane
        zdata : array of floats, shape (n,)
            value at each point in the triangulation
            must be the same size of the mesh

    Returns:
        zi : float / array of floats, shape (l,)
            interpolated value(s) of (xi,yi)
        err : int / array of ints, shape (l,)
            whether interpolation (0), extrapolation (1) or error (other)
    &#34;&#34;&#34;

    if zdata.size != self.npoints:
        raise ValueError(&#39;zdata should be same size as mesh&#39;)

    xi = np.atleast_1d(xi)
    yi = np.atleast_1d(yi)

    size = xi.size

    zi = np.empty(size)
    zierr = np.empty(size, dtype=np.int)

    zdata = self._shuffle_field(zdata)

    # iterate
    for i in range(0, size):
        ist = np.abs(self._x - xi[i]).argmin() + 1
        zi[i], zierr[i] = _srfpack.intrc0(xi[i], yi[i], self._x, self._y, zdata,\
                                   self.lst, self.lptr, self.lend, ist)

    return np.squeeze(zi), zierr</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.interpolate_nearest"><code class="name flex">
<span>def <span class="ident">interpolate_nearest</span></span>(<span>self, xi, yi, zdata)</span>
</code></dt>
<dd>
<section class="desc"><p>Nearest-neighbour interpolation.
Calls nearnd to find the index of the closest neighbours to xi,yi</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xi</code></strong> :&ensp;<code>float</code> / <code>array</code> of <code>floats</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>x coordinates on the Cartesian plane</dd>
<dt><strong><code>yi</code></strong> :&ensp;<code>float</code> / <code>array</code> of <code>floats</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>y coordinates on the Cartesian plane</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>zi</code></strong> :&ensp;<code>float</code> / <code>array</code> of <code>floats</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>nearest-neighbour interpolated value(s) of (xi,yi)</dd>
<dt><strong><code>err</code></strong> :&ensp;<code>int</code> / <code>array</code> of <code>ints</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>whether interpolation (0), extrapolation (1) or error (other)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def interpolate_nearest(self, xi, yi, zdata):
    &#34;&#34;&#34;
    Nearest-neighbour interpolation.
    Calls nearnd to find the index of the closest neighbours to xi,yi

    Args:
        xi : float / array of floats, shape (l,)
            x coordinates on the Cartesian plane
        yi : float / array of floats, shape (l,)
            y coordinates on the Cartesian plane

    Returns:
        zi : float / array of floats, shape (l,)
            nearest-neighbour interpolated value(s) of (xi,yi)
        err : int / array of ints, shape (l,)
            whether interpolation (0), extrapolation (1) or error (other)
    &#34;&#34;&#34;
    if zdata.size != self.npoints:
        raise ValueError(&#39;zdata should be same size as mesh&#39;)

    xi = np.atleast_1d(xi)
    yi = np.atleast_1d(yi)

    size = xi.size

    zdata = self._shuffle_field(zdata)

    zierr = np.zeros(size, dtype=np.int32)
    ist = np.ones(size, dtype=np.int32)
    ist, dist = _tripack.nearnds(xi, yi, ist, self._x, self._y,
                                 self.lst, self.lptr, self.lend)

    # check if interpolation or extrapolation
    hull_idx = self.convex_hull()
    hull_pts = self.points[hull_idx]
    hull_x = hull_pts[:,0]
    hull_y = hull_pts[:,1]

    for i in range(0, zierr.size):
        vector_det = (hull_x[1:] - hull_x[:-1])*(yi[i] - hull_y[:-1]) - \
                     (hull_y[1:] - hull_y[:-1])*(xi[i] - hull_x[:-1])

        # if vector_det &gt; 0: within convex hull
        # if vector_det = 0: on top of convex hull
        # if vector_det &lt; 0: outside convex hull
        zierr[i] = (vector_det &lt; 0).any()

    return np.squeeze(zdata[ist - 1]), zierr</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.join"><code class="name flex">
<span>def <span class="ident">join</span></span>(<span>self, t2, unique=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Join this triangulation with another. If the points are known to have no duplicates, then
set unique=False to skip the testing and duplicate removal</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def join(self, t2, unique=False):
    &#34;&#34;&#34;
    Join this triangulation with another. If the points are known to have no duplicates, then
    set unique=False to skip the testing and duplicate removal
    &#34;&#34;&#34;

    x_v1 = np.concatenate((self.x, t2.x), axis=0)
    y_v1 = np.concatenate((self.y, t2.y), axis=0)

    ## remove any duplicates

    if not unique:
        a = np.ascontiguousarray(np.vstack((x_v1, y_v1)).T)
        unique_a = np.unique(a.view([(&#39;&#39;, a.dtype)]*a.shape[1]))
        unique_coords = unique_a.view(a.dtype).reshape((unique_a.shape[0], a.shape[1]))

        x_v1 = unique_coords[:,0]
        y_v1 = unique_coords[:,1]

    return x_v1, y_v1</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.midpoint_refine_triangulation_by_vertices"><code class="name flex">
<span>def <span class="ident">midpoint_refine_triangulation_by_vertices</span></span>(<span>self, vertices)</span>
</code></dt>
<dd>
<section class="desc"><p>return points defining a refined triangulation obtained by bisection of all edges
in the triangulation connected to any of the vertices in the list provided</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def midpoint_refine_triangulation_by_vertices(self, vertices):
    &#34;&#34;&#34;
    return points defining a refined triangulation obtained by bisection of all edges
    in the triangulation connected to any of the vertices in the list provided
    &#34;&#34;&#34;

    xi, yi = self.segment_midpoints_by_vertices(vertices=vertices)

    x_v1 = np.concatenate((self.x, xi), axis=0)
    y_v1 = np.concatenate((self.y, yi), axis=0)

    return x_v1, y_v1</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.nearest_vertex"><code class="name flex">
<span>def <span class="ident">nearest_vertex</span></span>(<span>self, xi, yi)</span>
</code></dt>
<dd>
<section class="desc"><p>Locate the index of the nearest vertex to points (xi,yi)
and return the squared distance between (xi,yi) and
each nearest neighbour.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xi</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>Cartesian coordinates in the x direction</dd>
<dt><strong><code>yi</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>Cartesian coordinates in the y direction</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>array</code> of <code>ints</code></dt>
<dd>the nearest vertex to each of the supplied points</dd>
<dt><strong><code>dist</code></strong> :&ensp;<code>array</code> of <code>floats</code></dt>
<dd>squared distance to the closest vertex identified</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Faster searches can be obtained using a KDTree.
Store all x and y coordinates in a (c)KDTree, then query
a set of points to find their nearest neighbours.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def nearest_vertex(self, xi, yi):
    &#34;&#34;&#34;
    Locate the index of the nearest vertex to points (xi,yi)
    and return the squared distance between (xi,yi) and
    each nearest neighbour.

    Args:
        xi : array of floats, shape (l,)
            Cartesian coordinates in the x direction
        yi : array of floats, shape (l,)
            Cartesian coordinates in the y direction

    Returns:
        index : array of ints
            the nearest vertex to each of the supplied points
        dist : array of floats
            squared distance to the closest vertex identified

    Notes:
        Faster searches can be obtained using a KDTree.
        Store all x and y coordinates in a (c)KDTree, then query
        a set of points to find their nearest neighbours.
    &#34;&#34;&#34;
    n = np.array(xi).size
    xi = np.array(xi).reshape(n)
    yi = np.array(yi).reshape(n)

    idx  = np.empty_like(xi, dtype=np.int)
    dist = np.empty_like(xi, dtype=np.float)

    for pt in range(0, n):
        # i is the node at which we start the search
        # the closest x coordinate is a good place
        i = np.abs(self._x - xi[pt]).argmin()

        idx[pt], dist[pt] = _tripack.nearnd(xi[pt], yi[pt], i, self._x, self._y,\
                                            self.lst, self.lptr, self.lend)
    idx -= 1 # return to C ordering

    return self._deshuffle_simplices(idx), dist</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.nearest_vertices"><code class="name flex">
<span>def <span class="ident">nearest_vertices</span></span>(<span>self, x, y, k=1, max_distance=inf)</span>
</code></dt>
<dd>
<section class="desc"><p>Query the cKDtree for the nearest neighbours and Euclidean
distance from x,y points.</p>
<p>Returns 0, 0 if a cKDtree has not been constructed
(switch <code>tree=True</code> if you need this routine)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>1D</code> <code>array</code> of <code>Cartesian</code> <code>x</code> <code>coordinates</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>1D</code> <code>array</code> of <code>Cartesian</code> <code>y</code> <code>coordinates</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>int</code> (<code>defaul</code>=<code>1</code>)</dt>
<dd>number of nearest neighbours to return</dd>
<dt><strong><code>max_distance</code></strong> :&ensp;<code>float</code> (default: <code>inf</code>)</dt>
<dd>maximum Euclidean distance to search for neighbours</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>d</code></strong> :&ensp;<code>array</code> of <code>floats</code></dt>
<dd>Euclidean distance between each point and their
nearest neighbour(s)</dd>
<dt><strong><code>vert</code></strong> :&ensp;<code>array</code> of <code>ints</code></dt>
<dd>vertices of the nearest neighbour(s)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def nearest_vertices(self, x, y, k=1, max_distance=np.inf ):
    &#34;&#34;&#34;
    Query the cKDtree for the nearest neighbours and Euclidean
    distance from x,y points.

    Returns 0, 0 if a cKDtree has not been constructed
    (switch `tree=True` if you need this routine)

    Args:
        x : 1D array of Cartesian x coordinates
        y : 1D array of Cartesian y coordinates
        k : int (defaul=1)
            number of nearest neighbours to return
        max_distance : float (default: inf)
            maximum Euclidean distance to search for neighbours

    Returns:
        d : array of floats
            Euclidean distance between each point and their
            nearest neighbour(s)
        vert : array of ints
            vertices of the nearest neighbour(s)
    &#34;&#34;&#34;

    if self.tree == False or self.tree == None:
        return 0, 0

    xy = np.column_stack([x, y])

    dxy, vertices = self._cKDtree.query(xy, k=k, distance_upper_bound=max_distance)


    if k == 1:   # force this to be a 2D array
        vertices = np.reshape(vertices, (-1, 1))

    return dxy, vertices</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.neighbour_and_arc_simplices"><code class="name flex">
<span>def <span class="ident">neighbour_and_arc_simplices</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get indices of neighbour simplices for each simplex and arc indices.
Identical to get_neighbour_simplices() but also returns an array
of indices that reside on boundary hull, -1 denotes no neighbour.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def neighbour_and_arc_simplices(self):
    &#34;&#34;&#34;
    Get indices of neighbour simplices for each simplex and arc indices.
    Identical to get_neighbour_simplices() but also returns an array
    of indices that reside on boundary hull, -1 denotes no neighbour.
    &#34;&#34;&#34;
    nt, ltri, lct, ierr = _tripack.trlist(self.lst, self.lptr, self.lend, nrow=9)
    if ierr != 0:
        raise ValueError(&#39;ierr={} in trlist\n{}&#39;.format(ierr, _ier_codes[ierr]))
    ltri = ltri.T[:nt] - 1
    return ltri[:,3:6], ltri[:,6:]</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.neighbour_simplices"><code class="name flex">
<span>def <span class="ident">neighbour_simplices</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get indices of neighbour simplices for each simplex.
The kth neighbour is opposite to the kth vertex.
For simplices at the boundary, -1 denotes no neighbour.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def neighbour_simplices(self):
    &#34;&#34;&#34;
    Get indices of neighbour simplices for each simplex.
    The kth neighbour is opposite to the kth vertex.
    For simplices at the boundary, -1 denotes no neighbour.
    &#34;&#34;&#34;
    nt, ltri, lct, ierr = _tripack.trlist(self.lst, self.lptr, self.lend, nrow=6)
    if ierr != 0:
        raise ValueError(&#39;ierr={} in trlist\n{}&#39;.format(ierr, _ier_codes[ierr]))
    return ltri.T[:nt,3:] - 1</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.segment_midpoints"><code class="name flex">
<span>def <span class="ident">segment_midpoints</span></span>(<span>self, segments=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Identify the midpoints of every line segment in the triangulation.
If an array of segments of shape (no_of_segments,2) is given,
then the midpoints of only those segments is returned.</p>
<h2 id="notes">Notes</h2>
<p>Segments in the array must not be duplicates or the re-triangulation
will fail. Take care not to miss that (n1,n2) is equivalent to (n2,n1).</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def segment_midpoints(self, segments=None):
    &#34;&#34;&#34;
    Identify the midpoints of every line segment in the triangulation.
    If an array of segments of shape (no_of_segments,2) is given,
    then the midpoints of only those segments is returned.

    Notes:
        Segments in the array must not be duplicates or the re-triangulation
        will fail. Take care not to miss that (n1,n2) is equivalent to (n2,n1).
    &#34;&#34;&#34;

    if type(segments) == type(None):
        segments = self.identify_segments()
    points = self.points

    mids = (points[segments[:,0]] + points[segments[:,1]]) * 0.5
    mid_xpt, mid_ypt = mids[:,0], mids[:,1]

    return mid_xpt, mid_ypt</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.segment_midpoints_by_vertices"><code class="name flex">
<span>def <span class="ident">segment_midpoints_by_vertices</span></span>(<span>self, vertices)</span>
</code></dt>
<dd>
<section class="desc"><p>Add midpoints to any segment connected to the vertices in the
list / array provided.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def segment_midpoints_by_vertices(self, vertices):
    &#34;&#34;&#34;
    Add midpoints to any segment connected to the vertices in the
    list / array provided.
    &#34;&#34;&#34;

    segments = set()

    for vertex in vertices:
        neighbours = self.identify_vertex_neighbours(vertex)
        segments.update( min( tuple((vertex, n1)), tuple((n1, vertex))) for n1 in neighbours )

    segs = np.array(list(segments))

    new_midpoints = self.segment_midpoints(segments=segs)

    return new_midpoints</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.segment_tripoints"><code class="name flex">
<span>def <span class="ident">segment_tripoints</span></span>(<span>self, ratio=0.33333)</span>
</code></dt>
<dd>
<section class="desc"><p>Identify the trisection points of every line segment in the triangulation</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def segment_tripoints(self, ratio=0.33333):
    &#34;&#34;&#34;
    Identify the trisection points of every line segment in the triangulation
    &#34;&#34;&#34;

    segments = self.identify_segments()
    points = self.points

    mids1 = ratio*points[segments[:,0]] + (1.0-ratio)*points[segments[:,1]]
    mids2 = (1.0-ratio)*points[segments[:,0]] + ratio*points[segments[:,1]]

    mids = np.vstack((mids1,mids2))
    mid_xpt, mid_ypt = mids[:,0], mids[:,1]

    return mid_xpt, mid_ypt</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.smoothing"><code class="name flex">
<span>def <span class="ident">smoothing</span></span>(<span>self, f, w, sm, smtol, gstol)</span>
</code></dt>
<dd>
<section class="desc"><p>Smooths a surface <code>f</code> by choosing nodal function values and gradients to
minimize the linearized curvature of F subject to a bound on the
deviation from the data values. This is more appropriate than interpolation
when significant errors are present in the data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>field to apply smoothing on</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>weights associated with data value in <code>f</code>
<code>w[i] = 1/sigma_f**2</code> is a good rule of thumb.</dd>
<dt><strong><code>sm</code></strong> :&ensp;<code>float</code></dt>
<dd>positive parameter specifying an upper bound on Q2(f).
generally <code>n-sqrt(2n) &lt;= sm &lt;= n+sqrt(2n)</code></dd>
<dt><strong><code>smtol</code></strong> :&ensp;<code>float</code> [<code>0</code>,<code>1</code>]</dt>
<dd>specifies relative error in satisfying the constraint
<code>sm(1-smtol) &lt;= Q2 &lt;= sm(1+smtol)</code> between 0 and 1.</dd>
<dt><strong><code>gstol</code></strong> :&ensp;<code>float</code></dt>
<dd>tolerance for convergence.
<code>gstol = 0.05*mean(sigma_f)**2</code> is a good rule of thumb.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>f_smooth</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>smoothed version of f</dd>
<dt><strong><code>derivatives</code></strong> :&ensp;<code>tuple</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,<code>3</code>)</dt>
<dd>\( \partial f \partial y , \partial f \partial y \) first derivatives
of <code>f_smooth</code> in the x and y directions</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def smoothing(self, f, w, sm, smtol, gstol):
    r&#34;&#34;&#34;
    Smooths a surface `f` by choosing nodal function values and gradients to
    minimize the linearized curvature of F subject to a bound on the
    deviation from the data values. This is more appropriate than interpolation
    when significant errors are present in the data.

    Args:
        f : array of floats, shape (n,)
            field to apply smoothing on
        w : array of floats, shape (n,)
            weights associated with data value in `f`
            `w[i] = 1/sigma_f**2` is a good rule of thumb.
        sm : float
            positive parameter specifying an upper bound on Q2(f).
            generally `n-sqrt(2n) &lt;= sm &lt;= n+sqrt(2n)`
        smtol : float [0,1]
            specifies relative error in satisfying the constraint
            `sm(1-smtol) &lt;= Q2 &lt;= sm(1+smtol)` between 0 and 1.
        gstol : float
            tolerance for convergence.
            `gstol = 0.05*mean(sigma_f)**2` is a good rule of thumb.

    Returns:
        f_smooth : array of floats, shape (n,)
            smoothed version of f
        derivatives : tuple of floats, shape (n,3)
            \\( \partial f \partial y , \partial f \partial y \\) first derivatives
            of `f_smooth` in the x and y directions
    &#34;&#34;&#34;
    if f.size != self.npoints or f.size != w.size:
        raise ValueError(&#39;f and w should be the same size as mesh&#39;)

    f, w = self._shuffle_field(f, w)

    sigma = 0
    iflgs = 0

    f_smooth, df, ierr = _srfpack.smsurf(self.x, self.y, f, self.lst, self.lptr, self.lend,\
                                         iflgs, sigma, w, sm, smtol, gstol)

    if ierr &lt; 0:
        raise ValueError(&#39;ierr={} in gradg\n{}&#39;.format(ierr, _ier_codes[ierr]))
    if ierr == 1:
        raise RuntimeWarning(&#34;No errors were encountered but the constraint is not active --\n\
              F, FX, and FY are the values and partials of a linear function \
              which minimizes Q2(F), and Q1 = 0.&#34;)

    return self._deshuffle_field(f_smooth), self._deshuffle_field(df[0], df[1])</code></pre>
</details>
</dd>
<dt id="stripy.cartesian.Triangulation.uniformly_refine_triangulation"><code class="name flex">
<span>def <span class="ident">uniformly_refine_triangulation</span></span>(<span>self, faces=False, trisect=False)</span>
</code></dt>
<dd>
<section class="desc"><p>return points defining a refined triangulation obtained by bisection of all edges
in the triangulation</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def uniformly_refine_triangulation(self, faces=False, trisect=False):
    &#34;&#34;&#34;
    return points defining a refined triangulation obtained by bisection of all edges
    in the triangulation
    &#34;&#34;&#34;

    if faces:
        x_v1, y_v1 = self._add_face_centroids()

    else:
        if not trisect:
            x_v1, y_v1 = self._add_midpoints()
        else:
            x_v1, y_v1 = self._add_tripoints(ratio=0.333333)

    return x_v1, y_v1</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="stripy" href="index.html">stripy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="stripy.cartesian.remove_duplicates" href="#stripy.cartesian.remove_duplicates">remove_duplicates</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="stripy.cartesian.Triangulation" href="#stripy.cartesian.Triangulation">Triangulation</a></code></h4>
<ul class="">
<li><code><a title="stripy.cartesian.Triangulation.areas" href="#stripy.cartesian.Triangulation.areas">areas</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.centroid_refine_triangulation_by_triangles" href="#stripy.cartesian.Triangulation.centroid_refine_triangulation_by_triangles">centroid_refine_triangulation_by_triangles</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.centroid_refine_triangulation_by_vertices" href="#stripy.cartesian.Triangulation.centroid_refine_triangulation_by_vertices">centroid_refine_triangulation_by_vertices</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.containing_simplex_and_bcc" href="#stripy.cartesian.Triangulation.containing_simplex_and_bcc">containing_simplex_and_bcc</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.containing_triangle" href="#stripy.cartesian.Triangulation.containing_triangle">containing_triangle</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.convex_hull" href="#stripy.cartesian.Triangulation.convex_hull">convex_hull</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.edge_lengths" href="#stripy.cartesian.Triangulation.edge_lengths">edge_lengths</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.edge_refine_triangulation_by_triangles" href="#stripy.cartesian.Triangulation.edge_refine_triangulation_by_triangles">edge_refine_triangulation_by_triangles</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.edge_refine_triangulation_by_vertices" href="#stripy.cartesian.Triangulation.edge_refine_triangulation_by_vertices">edge_refine_triangulation_by_vertices</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.face_midpoints" href="#stripy.cartesian.Triangulation.face_midpoints">face_midpoints</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.gradient" href="#stripy.cartesian.Triangulation.gradient">gradient</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.gradient_local" href="#stripy.cartesian.Triangulation.gradient_local">gradient_local</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.identify_segments" href="#stripy.cartesian.Triangulation.identify_segments">identify_segments</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.identify_vertex_neighbours" href="#stripy.cartesian.Triangulation.identify_vertex_neighbours">identify_vertex_neighbours</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.identify_vertex_triangles" href="#stripy.cartesian.Triangulation.identify_vertex_triangles">identify_vertex_triangles</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.interpolate" href="#stripy.cartesian.Triangulation.interpolate">interpolate</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.interpolate_cubic" href="#stripy.cartesian.Triangulation.interpolate_cubic">interpolate_cubic</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.interpolate_linear" href="#stripy.cartesian.Triangulation.interpolate_linear">interpolate_linear</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.interpolate_nearest" href="#stripy.cartesian.Triangulation.interpolate_nearest">interpolate_nearest</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.join" href="#stripy.cartesian.Triangulation.join">join</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.midpoint_refine_triangulation_by_vertices" href="#stripy.cartesian.Triangulation.midpoint_refine_triangulation_by_vertices">midpoint_refine_triangulation_by_vertices</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.nearest_vertex" href="#stripy.cartesian.Triangulation.nearest_vertex">nearest_vertex</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.nearest_vertices" href="#stripy.cartesian.Triangulation.nearest_vertices">nearest_vertices</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.neighbour_and_arc_simplices" href="#stripy.cartesian.Triangulation.neighbour_and_arc_simplices">neighbour_and_arc_simplices</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.neighbour_simplices" href="#stripy.cartesian.Triangulation.neighbour_simplices">neighbour_simplices</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.points" href="#stripy.cartesian.Triangulation.points">points</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.segment_midpoints" href="#stripy.cartesian.Triangulation.segment_midpoints">segment_midpoints</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.segment_midpoints_by_vertices" href="#stripy.cartesian.Triangulation.segment_midpoints_by_vertices">segment_midpoints_by_vertices</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.segment_tripoints" href="#stripy.cartesian.Triangulation.segment_tripoints">segment_tripoints</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.simplices" href="#stripy.cartesian.Triangulation.simplices">simplices</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.smoothing" href="#stripy.cartesian.Triangulation.smoothing">smoothing</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.uniformly_refine_triangulation" href="#stripy.cartesian.Triangulation.uniformly_refine_triangulation">uniformly_refine_triangulation</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.x" href="#stripy.cartesian.Triangulation.x">x</a></code></li>
<li><code><a title="stripy.cartesian.Triangulation.y" href="#stripy.cartesian.Triangulation.y">y</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.5.2.dev91+g39781dd</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>